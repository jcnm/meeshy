/**
 * Service de traduction utilisant @huggingface/transformers
 * Gestion R√âELLE des mod√®les MT5 et NLLB avec t√©l√©chargement et cache automatique
 */

import { pipeline } from '@huggingface/transformers';
import { 
  UNIFIED_TRANSLATION_MODELS, 
  type UnifiedModelConfig,
  type TranslationModelType,
  estimateSystemCapabilities,
  selectBestModel
} from '@/lib/simplified-model-config';

export interface TranslationProgress {
  modelName: string;
  status: 'downloading' | 'loading' | 'ready' | 'error';
  progress?: number; // 0-100
  error?: string;
}

export interface TranslationResult {
  translatedText: string;
  sourceLanguage: string;
  targetLanguage: string;
  modelUsed: string;
  confidence?: number;
}

// Type pour le pipeline de traduction (simplifi√©)
type TranslationPipeline = any;

/**
 * Service de traduction utilisant Hugging Face Transformers
 */
export class HuggingFaceTranslationService {
  private static instance: HuggingFaceTranslationService;
  private loadedPipelines = new Map<string, TranslationPipeline>();
  private loadingPromises = new Map<string, Promise<TranslationPipeline>>();
  private progressCallbacks = new Map<string, (progress: TranslationProgress) => void>();
  
  // Cl√©s pour la persistance localStorage
  private readonly STORAGE_KEY_LOADED_MODELS = 'meeshy_loaded_models';
  private readonly STORAGE_KEY_MODEL_CACHE = 'meeshy_model_cache_metadata';

  static getInstance(): HuggingFaceTranslationService {
    if (!HuggingFaceTranslationService.instance) {
      HuggingFaceTranslationService.instance = new HuggingFaceTranslationService();
    }
    return HuggingFaceTranslationService.instance;
  }

  private constructor() {
    console.log('ü§ó Service de traduction Hugging Face initialis√©');
    this.loadPersistedState();
    
    // Recharger automatiquement les mod√®les persist√©s en arri√®re-plan
    this.autoReloadPersistedModels();
  }

  /**
   * Charge l'√©tat persist√© depuis localStorage
   */
  private loadPersistedState(): void {
    try {
      const savedModels = localStorage.getItem(this.STORAGE_KEY_LOADED_MODELS);
      if (savedModels) {
        const modelIds: string[] = JSON.parse(savedModels);
        console.log(`üìÇ Mod√®les persist√©s trouv√©s: ${modelIds.join(', ')}`);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Erreur lors du chargement de l\'√©tat persist√©:', error);
    }
  }

  /**
   * Recharge automatiquement les mod√®les persist√©s en arri√®re-plan
   */
  private async autoReloadPersistedModels(): Promise<void> {
    const persistedModels = this.getPersistedLoadedModels();
    
    if (persistedModels.length > 0) {
      console.log(`üîÑ Rechargement automatique de ${persistedModels.length} mod√®les persist√©s...`);
      
      // Recharger les mod√®les un par un pour √©viter de surcharger la m√©moire
      for (const modelType of persistedModels) {
        try {
          // Rechargement silencieux (sans callback de progression)
          await this.loadModel(modelType);
          console.log(`‚úÖ Mod√®le ${modelType} recharg√© automatiquement`);
        } catch (error) {
          console.warn(`‚ö†Ô∏è √âchec du rechargement automatique de ${modelType}:`, error);
          // Retirer le mod√®le d√©faillant de la persistance
          this.removeFromPersistence(modelType);
        }
      }
    }
  }

  /**
   * Retire un mod√®le de la persistance s'il ne peut pas √™tre recharg√©
   */
  private removeFromPersistence(modelType: TranslationModelType): void {
    try {
      const config = UNIFIED_TRANSLATION_MODELS[modelType];
      if (!config) return;

      const savedModels = localStorage.getItem(this.STORAGE_KEY_LOADED_MODELS);
      if (savedModels) {
        const modelIds: string[] = JSON.parse(savedModels);
        const filteredIds = modelIds.filter(id => id !== config.huggingFaceId);
        localStorage.setItem(this.STORAGE_KEY_LOADED_MODELS, JSON.stringify(filteredIds));
        console.log(`üóëÔ∏è Mod√®le ${modelType} retir√© de la persistance`);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Erreur lors de la suppression de persistance:', error);
    }
  }

  /**
   * Obtient les mod√®les marqu√©s comme charg√©s (incluant ceux persist√©s)
   */
  getPersistedLoadedModels(): TranslationModelType[] {
    try {
      const savedModels = localStorage.getItem(this.STORAGE_KEY_LOADED_MODELS);
      if (savedModels) {
        const modelIds: string[] = JSON.parse(savedModels);
        return Object.values(UNIFIED_TRANSLATION_MODELS)
          .filter(config => modelIds.includes(config.huggingFaceId))
          .map(config => config.name);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Erreur lors de la lecture des mod√®les persist√©s:', error);
    }
    return [];
  }

  /**
   * Sauvegarde l'√©tat dans localStorage
   */
  private persistState(): void {
    try {
      const loadedModelIds = Array.from(this.loadedPipelines.keys());
      localStorage.setItem(this.STORAGE_KEY_LOADED_MODELS, JSON.stringify(loadedModelIds));
      
      // Sauvegarder aussi les m√©tadonn√©es pour affichage
      const modelMetadata = loadedModelIds.map(modelId => {
        const config = Object.values(UNIFIED_TRANSLATION_MODELS).find(c => c.huggingFaceId === modelId);
        return {
          modelId,
          modelType: config?.name,
          displayName: config?.displayName,
          family: config?.family,
          loadedAt: new Date().toISOString()
        };
      });
      
      localStorage.setItem(this.STORAGE_KEY_MODEL_CACHE, JSON.stringify(modelMetadata));
      console.log(`üíæ √âtat persist√©: ${loadedModelIds.length} mod√®les`);
    } catch (error) {
      console.warn('‚ö†Ô∏è Erreur lors de la sauvegarde de l\'√©tat:', error);
    }
  }

  /**
   * Charge un mod√®le de traduction
   */
  async loadModel(
    modelType: TranslationModelType,
    onProgress?: (progress: TranslationProgress) => void
  ): Promise<TranslationPipeline> {
    const config = UNIFIED_TRANSLATION_MODELS[modelType];
    if (!config) {
      throw new Error(`Mod√®le ${modelType} non trouv√© dans la configuration`);
    }

    const modelId = config.huggingFaceId;
    
    // V√©rifier si d√©j√† charg√©
    if (this.loadedPipelines.has(modelId)) {
      console.log(`‚úÖ Mod√®le ${modelType} d√©j√† charg√©`);
      return this.loadedPipelines.get(modelId)!;
    }

    // V√©rifier si en cours de chargement
    if (this.loadingPromises.has(modelId)) {
      return this.loadingPromises.get(modelId)!;
    }

    // Enregistrer le callback de progression
    if (onProgress) {
      this.progressCallbacks.set(modelId, onProgress);
    }

    // D√©marrer le chargement
    const loadingPromise = this.performModelLoading(config);
    this.loadingPromises.set(modelId, loadingPromise);

    try {
      const translationPipeline = await loadingPromise;
      this.loadedPipelines.set(modelId, translationPipeline);
      this.loadingPromises.delete(modelId);
      
      // Persister l'√©tat apr√®s chargement r√©ussi
      this.persistState();
      
      this.notifyProgress(modelId, {
        modelName: modelType,
        status: 'ready',
        progress: 100
      });

      return translationPipeline;
    } catch (error) {
      this.loadingPromises.delete(modelId);
      this.notifyProgress(modelId, {
        modelName: modelType,
        status: 'error',
        error: error instanceof Error ? error.message : 'Erreur de chargement'
      });
      throw error;
    }
  }

  /**
   * Effectue le chargement r√©el du mod√®le
   */
  private async performModelLoading(config: UnifiedModelConfig): Promise<TranslationPipeline> {
    console.log(`üîÑ Chargement du mod√®le: ${config.huggingFaceId}`);
    
    this.notifyProgress(config.huggingFaceId, {
      modelName: config.name,
      status: 'downloading',
      progress: 0
    });

    try {
      // Charger le pipeline appropri√© selon le type de mod√®le
      // MT5 utilise text2text-generation, NLLB peut utiliser translation
      const taskType = config.family === 'MT5' ? 'text2text-generation' : 'translation';
      
      // @huggingface/transformers g√®re automatiquement le t√©l√©chargement et le cache
      const translationPipeline = await pipeline(taskType, config.huggingFaceId);

      console.log(`‚úÖ Mod√®le ${config.huggingFaceId} charg√© avec succ√®s`);
      return translationPipeline;

    } catch (error) {
      console.error(`‚ùå Erreur chargement ${config.huggingFaceId}:`, error);
      throw error;
    }
  }

  /**
   * Traduit un texte avec un mod√®le sp√©cifique
   */
  async translateText(
    text: string,
    sourceLanguage: string,
    targetLanguage: string,
    modelType: TranslationModelType,
    onProgress?: (progress: TranslationProgress) => void
  ): Promise<TranslationResult> {
    if (!text.trim()) {
      throw new Error('Le texte √† traduire ne peut pas √™tre vide');
    }

    // Limiter la taille du texte pour √©viter les erreurs de m√©moire
    if (text.length > 500) {
      throw new Error('Texte trop long (maximum 500 caract√®res)');
    }

    const config = UNIFIED_TRANSLATION_MODELS[modelType];
    if (!config) {
      throw new Error(`Mod√®le ${modelType} non support√©`);
    }

    console.log(`üîÑ Traduction: "${text}" (${sourceLanguage} ‚Üí ${targetLanguage}) avec ${modelType}`);

    try {
      // Charger le mod√®le si n√©cessaire
      const translationPipeline = await this.loadModel(modelType, onProgress);

      // Approche diff√©rente selon la famille de mod√®le
      let result: any;
      
      if (config.family === 'MT5') {
        // Pour MT5 : utiliser le format text2text-generation
        const prompt = `translate ${sourceLanguage} to ${targetLanguage}: ${text}`;
        console.log(`üîÑ MT5 prompt: "${prompt}"`);
        
        result = await translationPipeline(prompt, {
          max_length: Math.min(200, text.length * 2), // Limiter la longueur
          do_sample: false,
          temperature: 0.3,
          num_return_sequences: 1
        });
        
      } else if (config.family === 'NLLB') {
        // Pour NLLB : utiliser les codes de langue sp√©cifiques
        const srcLangCode = this.convertToNLLBCode(sourceLanguage);
        const tgtLangCode = this.convertToNLLBCode(targetLanguage);
        
        console.log(`üîÑ NLLB codes: ${srcLangCode} ‚Üí ${tgtLangCode}`);
        
        result = await translationPipeline(text, {
          src_lang: srcLangCode,
          tgt_lang: tgtLangCode,
          max_length: Math.min(200, text.length * 2) // Limiter la longueur
        });
        
      } else {
        throw new Error(`Famille de mod√®le non support√©e: ${config.family}`);
      }

      // Extraire le texte traduit
      let translatedText: string;
      
      if (Array.isArray(result) && result.length > 0) {
        const firstResult = result[0];
        if (typeof firstResult === 'object' && firstResult !== null) {
          // Essayer diff√©rentes propri√©t√©s possibles
          translatedText = (firstResult as any).translation_text || 
                          (firstResult as any).generated_text || 
                          (firstResult as any).text ||
                          String(firstResult);
        } else {
          translatedText = String(firstResult);
        }
      } else if (typeof result === 'object' && result !== null) {
        translatedText = (result as any).translation_text || 
                        (result as any).generated_text || 
                        (result as any).text ||
                        String(result);
      } else {
        translatedText = String(result);
      }

      // Nettoyer le texte traduit de mani√®re plus robuste
      translatedText = this.cleanTranslationText(translatedText.trim());

      // Si la traduction est vide ou identique, essayer un fallback
      if (!translatedText || translatedText === text) {
        console.warn(`‚ö†Ô∏è Traduction vide ou identique, utilisation du texte original`);
        translatedText = text;
      }

      console.log(`‚úÖ Traduction r√©ussie: "${translatedText}"`);

      return {
        translatedText,
        sourceLanguage,
        targetLanguage,
        modelUsed: config.displayName,
        confidence: 0.95 // Valeur par d√©faut, pourrait √™tre extraite du r√©sultat
      };

    } catch (error) {
      console.error(`‚ùå Erreur traduction avec ${modelType}:`, error);
      
      // Gestion sp√©cifique des erreurs de m√©moire et de tokenisation
      const errorMsg = error instanceof Error ? error.message : String(error);
      
      if (errorMsg.includes('522819016')) {
        throw new Error('Erreur de tokenisation: Le texte contient des caract√®res incompatibles avec ce mod√®le. Essayez de simplifier le texte ou d\'utiliser un autre mod√®le.');
      }
      
      if (errorMsg.includes('out of memory') || errorMsg.includes('OOM')) {
        throw new Error('M√©moire insuffisante: Essayez un texte plus court ou d√©chargez d\'autres mod√®les.');
      }
      
      throw new Error(`√âchec de traduction: ${errorMsg}`);
    }
  }

  /**
   * Convertit un code de langue ISO en code NLLB
   */
  private convertToNLLBCode(languageCode: string): string {
    const nllbCodes: Record<string, string> = {
      'en': 'eng_Latn',
      'fr': 'fra_Latn',
      'es': 'spa_Latn',
      'de': 'deu_Latn',
      'it': 'ita_Latn',
      'pt': 'por_Latn',
      'ru': 'rus_Cyrl',
      'ja': 'jpn_Jpan',
      'ko': 'kor_Hang',
      'zh': 'zho_Hans',
      'ar': 'arb_Arab',
      'hi': 'hin_Deva',
      'tr': 'tur_Latn',
      'pl': 'pol_Latn',
      'nl': 'nld_Latn',
      'sv': 'swe_Latn',
      'da': 'dan_Latn',
      'no': 'nor_Latn',
      'fi': 'fin_Latn',
      'cs': 'ces_Latn'
    };

    return nllbCodes[languageCode] || languageCode;
  }

  /**
   * Notifie la progression
   */
  private notifyProgress(modelId: string, progress: TranslationProgress): void {
    const callback = this.progressCallbacks.get(modelId);
    if (callback) {
      callback(progress);
    }
  }

  /**
   * V√©rifie si un mod√®le est charg√©
   */
  isModelLoaded(modelType: TranslationModelType): boolean {
    const config = UNIFIED_TRANSLATION_MODELS[modelType];
    return config ? this.loadedPipelines.has(config.huggingFaceId) : false;
  }

  /**
   * Obtient la liste des mod√®les charg√©s
   */
  getLoadedModels(): TranslationModelType[] {
    const loadedIds = Array.from(this.loadedPipelines.keys());
    return Object.values(UNIFIED_TRANSLATION_MODELS)
      .filter(config => loadedIds.includes(config.huggingFaceId))
      .map(config => config.name);
  }

  /**
   * D√©charge un mod√®le de la m√©moire
   */
  async unloadModel(modelType: TranslationModelType): Promise<boolean> {
    const config = UNIFIED_TRANSLATION_MODELS[modelType];
    if (!config) return false;

    const modelId = config.huggingFaceId;
    if (this.loadedPipelines.has(modelId)) {
      // Note: @huggingface/transformers ne fournit pas de m√©thode dispose explicite
      // mais la suppression de la r√©f√©rence permettra au garbage collector de faire son travail
      this.loadedPipelines.delete(modelId);
      this.progressCallbacks.delete(modelId);
      
      // Persister l'√©tat apr√®s d√©chargement
      this.persistState();
      
      console.log(`üóëÔ∏è Mod√®le ${modelType} d√©charg√©`);
      return true;
    }
    return false;
  }

  /**
   * D√©charge tous les mod√®les
   */
  async unloadAllModels(): Promise<void> {
    for (const modelType of this.getLoadedModels()) {
      await this.unloadModel(modelType);
    }
    console.log(`üßπ Tous les mod√®les d√©charg√©s`);
  }

  /**
   * Obtient des statistiques sur les mod√®les
   */
  getModelStats(): { 
    loaded: number; 
    total: number; 
    loadedModels: TranslationModelType[];
    availableModels: TranslationModelType[];
  } {
    const availableModels = Object.keys(UNIFIED_TRANSLATION_MODELS) as TranslationModelType[];
    const loadedModels = this.getLoadedModels();

    return {
      loaded: loadedModels.length,
      total: availableModels.length,
      loadedModels,
      availableModels
    };
  }

  /**
   * Pr√©charge les mod√®les recommand√©s pour le syst√®me
   */
  async preloadRecommendedModels(onProgress?: (progress: TranslationProgress) => void): Promise<void> {
    try {
      const capabilities = estimateSystemCapabilities();
      
      console.log(`üöÄ Pr√©chargement du mod√®le recommand√©: ${capabilities.recommendedModel}`);
      console.log(`üîÑ Raison: ${capabilities.reasoning}`);
      
      // Pr√©charger le mod√®le recommand√©
      await this.loadModel(capabilities.recommendedModel, onProgress);
      
      console.log(`‚úÖ Mod√®le recommand√© pr√©charg√©: ${capabilities.recommendedModel}`);
    } catch (error) {
      console.error('‚ùå Erreur lors du pr√©chargement du mod√®le:', error);
      throw error;
    }
  }

  /**
   * Charge automatiquement le meilleur mod√®le disponible pour une t√¢che de traduction
   */
  /**
   * Charge automatiquement le meilleur mod√®le disponible pour une t√¢che de traduction
   */
  async loadBestAvailableModel(
    onProgress?: (progress: TranslationProgress) => void
  ): Promise<{ modelType: TranslationModelType; pipeline: TranslationPipeline }> {
    // D'abord, v√©rifier s'il y a des mod√®les d√©j√† charg√©s
    const loadedModels = this.getLoadedModels();
    if (loadedModels.length > 0) {
      // Prendre le premier mod√®le charg√©
      const bestLoaded = loadedModels[0];
      const config = UNIFIED_TRANSLATION_MODELS[bestLoaded];
      const pipeline = this.loadedPipelines.get(config.huggingFaceId);
      
      if (pipeline) {
        console.log(`‚úÖ Utilisation du mod√®le d√©j√† charg√©: ${bestLoaded}`);
        return { modelType: bestLoaded, pipeline };
      }
    }

    // Sinon, v√©rifier les mod√®les persist√©s
    const persistedModels = this.getPersistedLoadedModels();
    if (persistedModels.length > 0) {
      const bestPersisted = persistedModels[0];
      try {
        const pipeline = await this.loadModel(bestPersisted, onProgress);
        console.log(`‚úÖ Mod√®le recharg√© depuis la persistance: ${bestPersisted}`);
        return { modelType: bestPersisted, pipeline };
      } catch {
        console.warn(`‚ö†Ô∏è √âchec du rechargement de ${bestPersisted}, essai du mod√®le recommand√©`);
      }
    }

    // En dernier recours, charger un mod√®le recommand√© selon les capacit√©s syst√®me
    try {
      const capabilities = estimateSystemCapabilities();
      const modelType = capabilities.recommendedModel;
      const pipeline = await this.loadModel(modelType, onProgress);
      
      console.log(`‚úÖ Mod√®le recommand√© charg√©: ${modelType}`);
      return { modelType, pipeline };
    } catch (error) {
      console.error('‚ùå Impossible de charger un mod√®le:', error);
      throw new Error('Aucun mod√®le de traduction disponible');
    }
  }

  /**
   * V√©rifie si un mod√®le est marqu√© comme charg√© (en m√©moire OU persist√©)
   */
  isModelLoadedOrPersisted(modelType: TranslationModelType): boolean {
    const config = UNIFIED_TRANSLATION_MODELS[modelType];
    if (!config) return false;
    
    // V√©rifier d'abord la m√©moire
    if (this.loadedPipelines.has(config.huggingFaceId)) {
      return true;
    }
    
    // Puis v√©rifier la persistance
    const persistedModels = this.getPersistedLoadedModels();
    return persistedModels.includes(modelType);
  }

  /**
   * Force le rechargement d'un mod√®le m√™me s'il est d√©j√† charg√©
   */
  async reloadModel(
    modelType: TranslationModelType,
    onProgress?: (progress: TranslationProgress) => void
  ): Promise<TranslationPipeline> {
    // D√©charger d'abord s'il est charg√©
    await this.unloadModel(modelType);
    
    // Puis recharger
    return this.loadModel(modelType, onProgress);
  }

  /**
   * Nettoie compl√®tement le cache et la persistance
   */
  async clearAllCache(): Promise<void> {
    // D√©charger tous les mod√®les de la m√©moire
    await this.unloadAllModels();
    
    // Nettoyer le localStorage
    localStorage.removeItem(this.STORAGE_KEY_LOADED_MODELS);
    localStorage.removeItem(this.STORAGE_KEY_MODEL_CACHE);
    
    console.log(`üßπ Cache et persistance nettoy√©s compl√®tement`);
  }

  /**
   * Nettoie le texte traduit des tokens et artefacts ind√©sirables
   */
  private cleanTranslationText(text: string): string {
    if (!text) return '';
    
    return text
      // Supprimer les tokens extra_id probl√©matiques
      .replace(/<extra_id_\d+>/g, '')
      // Supprimer les tokens de sous-mot
      .replace(/‚ñÅ/g, ' ')
      // Supprimer les tokens de d√©but/fin
      .replace(/<s>|<\/s>/g, '')
      // Supprimer les tokens de padding
      .replace(/<pad>/g, '')
      // Supprimer les tokens inconnus
      .replace(/<unk>/g, '')
      // Supprimer les tokens de masquage
      .replace(/<mask>/g, '')
      // Normaliser les espaces multiples
      .replace(/\s+/g, ' ')
      // Supprimer les espaces en d√©but et fin
      .trim();
  }
}

// Export par d√©faut pour faciliter l'utilisation
export default HuggingFaceTranslationService;
