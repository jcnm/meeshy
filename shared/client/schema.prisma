generator client {
  provider      = "prisma-client-js"
  output        = "./client"
  binaryTargets = ["native"]
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

/// Utilisateur enregistré de la plateforme
model User {
  id                          String    @id @default(auto()) @map("_id") @db.ObjectId
  username                    String    @unique
  firstName                   String
  lastName                    String
  bio                         String    @default("")
  email                       String    @unique
  phoneNumber                 String?
  password                    String
  displayName                 String?
  avatar                      String?
  isOnline                    Boolean   @default(false)
  lastSeen                    DateTime  @default(now())
  lastActiveAt                DateTime  @default(now())
  systemLanguage              String    @default("en")
  regionalLanguage            String    @default("fr")
  customDestinationLanguage   String?
  autoTranslateEnabled        Boolean   @default(true)
  translateToSystemLanguage   Boolean   @default(true)
  translateToRegionalLanguage Boolean   @default(false)
  useCustomDestination        Boolean   @default(false)
  /// USER, ADMIN, MODO, AUDIT, ANALYST, BIGBOSS
  role                        String    @default("USER")
  isActive                    Boolean   @default(true)
  deactivatedAt               DateTime?
  createdAt                   DateTime  @default(now())
  updatedAt                   DateTime  @updatedAt

  createdCommunities      Community[]              @relation("CommunityCreator")
  communityMemberships    CommunityMember[]
  conversations           ConversationMember[]
  conversationPreferences ConversationPreference[]
  createdShareLinks       ConversationShareLink[]  @relation("ShareLinkCreator")
  receivedFriendRequests  FriendRequest[]          @relation("FriendRequestReceiver")
  sentFriendRequests      FriendRequest[]          @relation("FriendRequestSender")
  messageStatus           MessageStatus[]
  sentMessages            Message[]                @relation("MessageSender")
  notifications           Notification[]
  typingIndicators        TypingIndicator[]
  preferences             UserPreference[]
  stats                   UserStats?
  createdAffiliateTokens  AffiliateToken[]         @relation("AffiliateTokenCreator")
  affiliateRelations      AffiliateRelation[]      @relation("AffiliateUser")
  referredRelations       AffiliateRelation[]      @relation("ReferredUser")
}

/// Conversation entre utilisateurs (direct, group, public, global)
model Conversation {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  /// Identifiant lisible par l'homme (ex: "mee_meeshy", "general", "mee_support")
  identifier    String?  @unique
  /// direct, group, public, global
  type          String
  title         String?
  description   String?
  image         String?
  avatar        String?
  communityId   String?  @db.ObjectId
  isActive      Boolean  @default(true)
  isArchived    Boolean  @default(false)
  lastMessageAt DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  anonymousParticipants AnonymousParticipant[]
  members               ConversationMember[]
  preferences           ConversationPreference[]
  shareLinks            ConversationShareLink[]
  community             Community?               @relation(fields: [communityId], references: [id])
  messages              Message[]
  typingIndicators      TypingIndicator[]
}

/// Appartenance d'un utilisateur à une conversation
model ConversationMember {
  id               String    @id @default(auto()) @map("_id") @db.ObjectId
  conversationId   String    @db.ObjectId
  userId           String    @db.ObjectId
  /// admin, moderator, member
  role             String    @default("member")
  canSendMessage   Boolean   @default(true)
  canSendFiles     Boolean   @default(true)
  canSendImages    Boolean   @default(true)
  canSendVideos    Boolean   @default(true)
  canSendAudios    Boolean   @default(true)
  canSendLocations Boolean   @default(true)
  canSendLinks     Boolean   @default(true)
  joinedAt         DateTime  @default(now())
  leftAt           DateTime?
  isActive         Boolean   @default(true)

  user         User         @relation(fields: [userId], references: [id])
  conversation Conversation @relation(fields: [conversationId], references: [id])
}

/// Lien de partage pour accès anonyme à une conversation
model ConversationShareLink {
  id                     String    @id @default(auto()) @map("_id") @db.ObjectId
  linkId                 String    @unique
  /// Identifiant lisible par l'homme (ex: "mshy_meeshy-public", "mshy_support-link")
  identifier             String?   @unique
  conversationId         String    @db.ObjectId
  createdBy              String    @db.ObjectId
  name                   String?
  description            String?
  maxUses                Int?
  currentUses            Int       @default(0)
  maxConcurrentUsers     Int?
  currentConcurrentUsers Int       @default(0)
  maxUniqueSessions      Int?
  currentUniqueSessions  Int       @default(0)
  expiresAt              DateTime?
  isActive               Boolean   @default(true)
  allowAnonymousMessages Boolean   @default(true)
  allowAnonymousFiles    Boolean   @default(false)
  allowAnonymousImages   Boolean   @default(true)
  allowViewHistory       Boolean   @default(true)
  requireNickname        Boolean   @default(true)
  requireEmail           Boolean   @default(false)
  allowedCountries       String[]  @default([])
  allowedLanguages       String[]  @default([])
  allowedIpRanges        String[]  @default([])
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt

  anonymousParticipants AnonymousParticipant[] @relation("ShareLinkParticipants")
  creator               User                   @relation("ShareLinkCreator", fields: [createdBy], references: [id])
  conversation          Conversation           @relation(fields: [conversationId], references: [id])
}

/// Participant anonyme via lien de partage
model AnonymousParticipant {
  id                String    @id @default(auto()) @map("_id") @db.ObjectId
  conversationId    String    @db.ObjectId
  shareLinkId       String    @db.ObjectId
  firstName         String
  lastName          String
  username          String
  email             String?
  sessionToken      String    @unique
  ipAddress         String?
  country           String?
  language          String    @default("fr")
  deviceFingerprint String?
  isActive          Boolean   @default(true)
  isOnline          Boolean   @default(false)
  lastActiveAt      DateTime  @default(now())
  canSendMessages   Boolean   @default(true)
  canSendFiles      Boolean   @default(false)
  canSendImages     Boolean   @default(true)
  joinedAt          DateTime  @default(now())
  lastSeenAt        DateTime  @default(now())
  leftAt            DateTime?

  shareLink    ConversationShareLink @relation("ShareLinkParticipants", fields: [shareLinkId], references: [id])
  conversation Conversation          @relation(fields: [conversationId], references: [id])
  sentMessages Message[]             @relation("AnonymousMessageSender")
}

/// Message dans une conversation
model Message {
  id                String    @id @default(auto()) @map("_id") @db.ObjectId
  conversationId    String    @db.ObjectId
  senderId          String?   @db.ObjectId
  anonymousSenderId String?   @db.ObjectId
  content           String
  originalLanguage  String    @default("fr")
  /// text, image, file, audio, video, location, system
  messageType       String    @default("text")
  isEdited          Boolean   @default(false)
  editedAt          DateTime?
  isDeleted         Boolean   @default(false)
  deletedAt         DateTime?
  replyToId         String?   @db.ObjectId
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  status          MessageStatus[]       @relation("MessageStatusMessage")
  statusResponses MessageStatus[]       @relation("MessageStatusResponse")
  translations    MessageTranslation[]
  replyTo         Message?              @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies         Message[]             @relation("MessageReplies")
  anonymousSender AnonymousParticipant? @relation("AnonymousMessageSender", fields: [anonymousSenderId], references: [id])
  sender          User?                 @relation("MessageSender", fields: [senderId], references: [id])
  conversation    Conversation          @relation(fields: [conversationId], references: [id])
}

/// Traduction d'un message
model MessageTranslation {
  id                String   @id @default(auto()) @map("_id") @db.ObjectId
  messageId         String   @db.ObjectId
  sourceLanguage    String
  targetLanguage    String
  translatedContent String
  translationModel  String
  cacheKey          String   @unique
  confidenceScore   Float?
  createdAt         DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([messageId, targetLanguage], name: "message_target_language_unique")
}

/// Statut de reception, lecture ou réponse d'un message par un utilisateur
model MessageStatus {
  id         String    @id @default(auto()) @map("_id") @db.ObjectId
  messageId  String    @db.ObjectId
  userId     String    @db.ObjectId
  receivedAt DateTime? /// Quand le message a été reçu par l'utilisateur
  readAt     DateTime? /// Quand le message a été lu par l'utilisateur
  answer     String?   @db.ObjectId /// Last answer to the message by the user
  user       User      @relation(fields: [userId], references: [id])
  message    Message   @relation("MessageStatusMessage", fields: [messageId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  response   Message?  @relation("MessageStatusResponse", fields: [answer], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([messageId, userId], name: "messageId_userId")
  @@map("message_status")
}

/// Demande d'amitié entre utilisateurs
model FriendRequest {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  senderId   String   @db.ObjectId
  receiverId String   @db.ObjectId
  /// pending, accepted, rejected, blocked
  status     String   @default("pending")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  receiver User @relation("FriendRequestReceiver", fields: [receiverId], references: [id])
  sender   User @relation("FriendRequestSender", fields: [senderId], references: [id])
}

/// Indicateur de frappe en cours pour des tests... A supprimer après les tests
model TypingIndicator {
  id             String   @id @default(auto()) @map("_id") @db.ObjectId
  conversationId String   @db.ObjectId
  userId         String   @db.ObjectId
  isTyping       Boolean  @default(true)
  startedAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user         User         @relation(fields: [userId], references: [id])
  conversation Conversation @relation(fields: [conversationId], references: [id])
}

/// Notification pour un utilisateur
model Notification {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  userId    String    @db.ObjectId
  /// new_conversation, new_message, message_edited, friend_request, etc.
  type      String
  title     String
  content   String
  data      String?
  priority  String    @default("normal")
  isRead    Boolean   @default(false)
  emailSent Boolean   @default(false)
  pushSent  Boolean   @default(false)
  expiresAt DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id])
}

/// Communauté (représente une communauté de conversation)
model Community {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  /// Identifiant lisible par l'homme (ex: "mshy_meeshy-paris", "mshy_support-lycee-njanda")
  identifier  String?  @unique
  name        String
  description String?
  avatar      String?
  isPrivate   Boolean  @default(true)
  createdBy   String   @db.ObjectId
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members      CommunityMember[]
  creator      User              @relation("CommunityCreator", fields: [createdBy], references: [id])
  Conversation Conversation[]
}

/// Appartenance aux communautés 
model CommunityMember {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  communityId String   @db.ObjectId
  userId      String   @db.ObjectId
  joinedAt    DateTime @default(now())
  /// admin, moderator, member
  role        String   @default("member")

  user      User      @relation(fields: [userId], references: [id])
  community Community @relation(fields: [communityId], references: [id])
}

/// Statistiques d'utilisation d'un utilisateur
model UserStats {
  id                       String   @id @default(auto()) @map("_id") @db.ObjectId
  userId                   String   @unique @db.ObjectId
  messagesSent             Int      @default(0)
  messagesReceived         Int      @default(0)
  charactersTyped          Int      @default(0)
  imageMessagesSent        Int      @default(0)
  filesShared              Int      @default(0)
  conversationsJoined      Int      @default(0)
  communitiesCreated       Int      @default(0)
  friendsAdded             Int      @default(0)
  friendRequestsSent       Int      @default(0)
  translationsUsed         Int      @default(0)
  languagesDetected        Int      @default(0)
  autoTranslateTimeMinutes Int      @default(0)
  totalOnlineTimeMinutes   Int      @default(0)
  sessionCount             Int      @default(0)
  lastActiveAt             DateTime @default(now())
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])
}

/// Préférence utilisateur générale
model UserPreference {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  userId      String   @db.ObjectId
  key         String
  value       String
  valueType   String   @default("string")
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])
}

/// Préférence spécifique à une conversation
model ConversationPreference {
  id             String   @id @default(auto()) @map("_id") @db.ObjectId
  conversationId String   @db.ObjectId
  userId         String   @db.ObjectId
  key            String
  value          String
  valueType      String   @default("string")
  description    String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user         User         @relation(fields: [userId], references: [id])
  conversation Conversation @relation(fields: [conversationId], references: [id])
}

/// Token d'affiliation pour inviter des utilisateurs
model AffiliateToken {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  token       String    @unique
  name        String // Nom de la campagne d'affiliation
  createdBy   String    @db.ObjectId
  maxUses     Int? // Limite d'utilisation (null = illimité)
  currentUses Int       @default(0)
  expiresAt   DateTime? // Date d'expiration (null = pas d'expiration)
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  creator      User                @relation("AffiliateTokenCreator", fields: [createdBy], references: [id])
  affiliations AffiliateRelation[]
}

/// Relation d'affiliation entre utilisateurs
model AffiliateRelation {
  id               String    @id @default(auto()) @map("_id") @db.ObjectId
  affiliateTokenId String    @db.ObjectId
  affiliateUserId  String    @db.ObjectId // Utilisateur qui a invité
  referredUserId   String    @db.ObjectId // Utilisateur invité
  status           String    @default("pending") // pending, completed, expired
  createdAt        DateTime  @default(now())
  completedAt      DateTime? // Date de finalisation de l'inscription

  affiliateToken AffiliateToken @relation(fields: [affiliateTokenId], references: [id])
  affiliateUser  User           @relation("AffiliateUser", fields: [affiliateUserId], references: [id])
  referredUser   User           @relation("ReferredUser", fields: [referredUserId], references: [id])
}
