generator client {
  provider = "prisma-client-py"
  interface = "asyncio"
  recursive_type_depth = 5
  
  binaryTargets = ["native"]
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

/// Utilisateur enregistr√© de la plateforme
model User {
  id                          String                   @id @default(auto()) @map("_id") @db.ObjectId
  username                    String                   @unique
  firstName                   String
  lastName                    String
  bio                         String                   @default("")
  email                       String                   @unique
  phoneNumber                 String?
  password                    String
  displayName                 String?
  avatar                      String?
  isOnline                    Boolean                  @default(false)
  lastSeen                    DateTime                 @default(now())
  lastActiveAt                DateTime                 @default(now())
  systemLanguage              String                   @default("en")
  regionalLanguage            String                   @default("fr")
  customDestinationLanguage   String?
  autoTranslateEnabled        Boolean                  @default(true)
  translateToSystemLanguage   Boolean                  @default(true)
  translateToRegionalLanguage Boolean                  @default(false)
  useCustomDestination        Boolean                  @default(false)
  /// USER, ADMIN, MODO, AUDIT, ANALYST, BIGBOSS
  role                        String                   @default("USER")
  isActive                    Boolean                  @default(true)
  deactivatedAt               DateTime?

  // Security & verification fields
  emailVerified               Boolean?                 @default(false)
  emailVerifiedAt             DateTime?
  phoneVerified               Boolean?                 @default(false)
  phoneVerifiedAt             DateTime?
  twoFactorEnabled            Boolean?                 @default(false)
  failedLoginAttempts         Int?                     @default(0)
  lockedUntil                 DateTime?
  lastPasswordChange          DateTime?                @default(now())

  // Soft delete fields
  deletedAt                   DateTime?
  deletedBy                   String?                  @db.ObjectId

  // Profile completion
  profileCompletionRate       Int?                     @default(0)

  createdAt                   DateTime                 @default(now())
  updatedAt                   DateTime                 @updatedAt
  
  createdCommunities          Community[]              @relation("CommunityCreator")
  communityMemberships        CommunityMember[]
  conversations               ConversationMember[]
  conversationPreferences     ConversationPreference[]
  createdShareLinks           ConversationShareLink[]  @relation("ShareLinkCreator")
  receivedFriendRequests      FriendRequest[]          @relation("FriendRequestReceiver")
  sentFriendRequests          FriendRequest[]          @relation("FriendRequestSender")
  messageStatus               MessageStatus[]
  sentMessages                Message[]                @relation("MessageSender")
  reactions                   Reaction[]               @relation("UserReactions")
  notifications               Notification[]
  typingIndicators            TypingIndicator[]
  preferences                 UserPreference[]
  stats                       UserStats?
  createdAffiliateTokens      AffiliateToken[]         @relation("AffiliateTokenCreator")
  affiliateRelations          AffiliateRelation[]      @relation("AffiliateUser")
  referredRelations           AffiliateRelation[]      @relation("ReferredUser")
  createdTrackingLinks        TrackingLink[]           @relation("TrackingLinkCreator")
  trackingLinkClicks          TrackingLinkClick[]      @relation("TrackingLinkClickUser")
  initiatedCalls              CallSession[]            @relation("CallInitiator")
  callParticipations          CallParticipant[]        @relation("CallParticipants")
}

/// Conversation entre utilisateurs (direct, group, public, global)
model Conversation {
  id                    String                   @id @default(auto()) @map("_id") @db.ObjectId
  /// Identifiant lisible par l'homme (ex: "mee_meeshy", "general", "mee_support")
  identifier            String                   @unique
  /// direct, group, public, global
  type                  String
  title                 String?
  description           String?
  image                 String?
  avatar                String?
  communityId           String?                  @db.ObjectId
  isActive              Boolean                  @default(true)
  isArchived            Boolean                  @default(false)
  lastMessageAt         DateTime                 @default(now())
  createdAt             DateTime                 @default(now())
  updatedAt             DateTime                 @updatedAt
  
  anonymousParticipants AnonymousParticipant[]
  members               ConversationMember[]
  preferences           ConversationPreference[]
  shareLinks            ConversationShareLink[]
  community             Community?               @relation(fields: [communityId], references: [id])
  messages              Message[]
  typingIndicators      TypingIndicator[]
  callSessions          CallSession[]
}

/// Appartenance d'un utilisateur √† une conversation
model ConversationMember {
  id               String       @id @default(auto()) @map("_id") @db.ObjectId
  conversationId   String       @db.ObjectId
  userId           String       @db.ObjectId
  /// admin, moderator, member
  role             String       @default("member")
  canSendMessage   Boolean      @default(true)
  canSendFiles     Boolean      @default(true)
  canSendImages    Boolean      @default(true)
  canSendVideos    Boolean      @default(true)
  canSendAudios    Boolean      @default(true)
  canSendLocations Boolean      @default(true)
  canSendLinks     Boolean      @default(true)
  joinedAt         DateTime     @default(now())
  leftAt           DateTime?
  isActive         Boolean      @default(true)
  
  user             User         @relation(fields: [userId], references: [id])
  conversation     Conversation @relation(fields: [conversationId], references: [id])
}

/// Lien de partage pour acc√®s anonyme √† une conversation
model ConversationShareLink {
  id                     String                 @id @default(auto()) @map("_id") @db.ObjectId
  linkId                 String                 @unique
  /// Identifiant lisible par l'homme (ex: "mshy_meeshy-public", "mshy_support-link")
  identifier             String                 @unique
  conversationId         String                 @db.ObjectId
  createdBy              String                 @db.ObjectId
  name                   String?
  description            String?
  maxUses                Int?
  currentUses            Int                    @default(0)
  maxConcurrentUsers     Int?
  currentConcurrentUsers Int                    @default(0)
  maxUniqueSessions      Int?
  currentUniqueSessions  Int                    @default(0)
  expiresAt              DateTime?
  isActive               Boolean                @default(true)
  allowAnonymousMessages Boolean                @default(true)
  allowAnonymousFiles    Boolean                @default(false)
  allowAnonymousImages   Boolean                @default(true)
  allowViewHistory       Boolean                @default(true)
  /// Si true, seuls les utilisateurs avec compte peuvent rejoindre (bloque l'acc√®s anonyme)
  requireAccount         Boolean                @default(false)
  requireNickname        Boolean                @default(true)
  requireEmail           Boolean                @default(false)
  /// Si true, demande la date de naissance pour v√©rifier l'√¢ge minimum
  requireBirthday        Boolean                @default(false)
  allowedCountries       String[]               @default([])
  allowedLanguages       String[]               @default([])
  allowedIpRanges        String[]               @default([])
  createdAt              DateTime               @default(now())
  updatedAt              DateTime               @updatedAt
  
  anonymousParticipants  AnonymousParticipant[] @relation("ShareLinkParticipants")
  creator                User                   @relation("ShareLinkCreator", fields: [createdBy], references: [id])
  conversation           Conversation           @relation(fields: [conversationId], references: [id])
}

/// Participant anonyme via lien de partage
model AnonymousParticipant {
  id              String                @id @default(auto()) @map("_id") @db.ObjectId
  conversationId  String                @db.ObjectId
  shareLinkId     String                @db.ObjectId
  firstName       String
  lastName        String
  username        String
  email           String?
  birthday        DateTime?
  sessionToken    String                @unique
  ipAddress       String?
  country         String?
  language        String                @default("fr")
  deviceFingerprint String?
  isActive        Boolean               @default(true)
  isOnline        Boolean               @default(false)
  lastActiveAt    DateTime              @default(now())
  canSendMessages Boolean               @default(true)
  canSendFiles    Boolean               @default(false)
  canSendImages   Boolean               @default(true)
  joinedAt        DateTime              @default(now())
  lastSeenAt      DateTime              @default(now())
  leftAt          DateTime?
  
  shareLink       ConversationShareLink @relation("ShareLinkParticipants", fields: [shareLinkId], references: [id])
  conversation    Conversation          @relation(fields: [conversationId], references: [id])
  sentMessages    Message[]             @relation("AnonymousMessageSender")
  reactions       Reaction[]            @relation("AnonymousReactions")
  trackingLinkClicks TrackingLinkClick[] @relation("TrackingLinkClickAnonymous")
}

/// Message dans une conversation
model Message {
  id                String                @id @default(auto()) @map("_id") @db.ObjectId
  conversationId    String                @db.ObjectId
  senderId          String?               @db.ObjectId
  anonymousSenderId String?               @db.ObjectId
  content           String
  originalLanguage  String                @default("fr")
  /// text, image, file, audio, video, location, system
  messageType       String                @default("text")
  isEdited          Boolean               @default(false)
  editedAt          DateTime?
  isDeleted         Boolean               @default(false)
  deletedAt         DateTime?
  replyToId         String?               @db.ObjectId
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  
  status            MessageStatus[]       @relation("MessageStatusMessage")
  statusResponses   MessageStatus[]       @relation("MessageStatusResponse")
  translations      MessageTranslation[]
  attachments       MessageAttachment[]
  reactions         Reaction[]            @relation("MessageReactions")
  replyTo           Message?              @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies           Message[]             @relation("MessageReplies")
  anonymousSender   AnonymousParticipant? @relation("AnonymousMessageSender", fields: [anonymousSenderId], references: [id])
  sender            User?                 @relation("MessageSender", fields: [senderId], references: [id])
  conversation      Conversation          @relation(fields: [conversationId], references: [id])
}

/// Traduction d'un message
model MessageTranslation {
  id                String   @id @default(auto()) @map("_id") @db.ObjectId
  messageId         String   @db.ObjectId
  sourceLanguage    String
  targetLanguage    String
  translatedContent String
  translationModel  String   // "basic", "medium", "premium"
  cacheKey          String   @unique
  confidenceScore   Float?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  message           Message  @relation(fields: [messageId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  
  // Contrainte d'unicit√©: une seule traduction par message et langue cible
  // Permet de mettre √† jour la traduction existante vers un niveau sup√©rieur
  @@unique([messageId, targetLanguage], name: "messageId_targetLanguage")
  @@index([messageId])
  @@index([targetLanguage])
  @@index([translationModel])
}

/// Attachement de fichier pour un message
model MessageAttachment {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  messageId       String   @db.ObjectId
  fileName        String   // Nom de fichier g√©n√©r√© (unique)
  originalName    String   // Nom original du fichier
  mimeType        String   // Type MIME (image/jpeg, application/pdf, etc.)
  fileSize        Int      // Taille en bytes
  filePath        String   // Chemin relatif: attachments/YYYY/mm/userId/filename
  fileUrl         String   // URL compl√®te pour acc√®s
  
  // M√©tadonn√©es sp√©cifiques aux images
  width           Int?
  height          Int?
  thumbnailPath   String?  // Miniature g√©n√©r√©e pour images
  thumbnailUrl    String?
  
  // M√©tadonn√©es sp√©cifiques audio/vid√©o
  duration        Int?     // Dur√©e en secondes
  bitrate         Int?     // D√©bit en bps (bits per second)
  sampleRate      Int?     // Fr√©quence d'√©chantillonnage en Hz (ex: 44100, 48000)
  codec           String?  // Codec audio/vid√©o (ex: "opus", "aac", "vorbis", "h264")
  channels        Int?     // Nombre de canaux audio (1: mono, 2: stereo)

  // M√©tadonn√©es g√©n√©rales
  uploadedBy      String   @db.ObjectId // ID utilisateur ou anonyme
  isAnonymous     Boolean  @default(false)
  
  createdAt       DateTime @default(now())
  /// Attachment metadata
  metadata        Json?           // JSON blob for additional metadata
  
  message         Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  @@index([messageId])
  @@index([uploadedBy])
}

/// Statut de reception, lecture ou r√©ponse d'un message par un utilisateur
model MessageStatus {
  id         String    @id @default(auto()) @map("_id") @db.ObjectId
  messageId  String    @db.ObjectId
  userId     String    @db.ObjectId
  receivedAt DateTime? /// Quand le message a √©t√© re√ßu par l'utilisateur
  readAt     DateTime? /// Quand le message a √©t√© lu par l'utilisateur
  answer     String?   @db.ObjectId /// Last answer to the message by the user
  user       User      @relation(fields: [userId], references: [id])
  message    Message   @relation("MessageStatusMessage", fields: [messageId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  response   Message?  @relation("MessageStatusResponse", fields: [answer], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([messageId, userId], name: "messageId_userId")
}

/// R√©action emoji sur un message par un utilisateur
model Reaction {
  id              String                @id @default(auto()) @map("_id") @db.ObjectId
  messageId       String                @db.ObjectId
  userId          String?               @db.ObjectId // null pour utilisateurs anonymes
  anonymousUserId String?               @db.ObjectId // ID de l'utilisateur anonyme
  emoji           String                // Emoji libre (ex: üéâ, ‚ù§Ô∏è, üî•, ‚≠ê)
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  
  message         Message               @relation("MessageReactions", fields: [messageId], references: [id], onDelete: Cascade)
  user            User?                 @relation("UserReactions", fields: [userId], references: [id], onDelete: Cascade)
  anonymousUser   AnonymousParticipant? @relation("AnonymousReactions", fields: [anonymousUserId], references: [id], onDelete: Cascade)
  
  // Contrainte: un utilisateur ne peut ajouter le m√™me emoji qu'une seule fois par message
  @@unique([messageId, userId, emoji], name: "user_reaction_unique")
  // Contrainte: un utilisateur anonyme ne peut ajouter le m√™me emoji qu'une seule fois par message
  @@unique([messageId, anonymousUserId, emoji], name: "anonymous_reaction_unique")
  @@index([messageId])
  @@index([userId])
  @@index([anonymousUserId])
  @@index([emoji])
}

/// Demande d'amiti√© entre utilisateurs
model FriendRequest {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  senderId   String   @db.ObjectId
  receiverId String   @db.ObjectId
  /// pending, accepted, rejected, blocked
  status     String   @default("pending")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  receiver   User     @relation("FriendRequestReceiver", fields: [receiverId], references: [id])
  sender     User     @relation("FriendRequestSender", fields: [senderId], references: [id])
}

/// Indicateur de frappe en cours pour des tests... A supprimer apr√®s les tests
model TypingIndicator {
  id             String       @id @default(auto()) @map("_id") @db.ObjectId
  conversationId String       @db.ObjectId
  userId         String       @db.ObjectId
  isTyping       Boolean      @default(true)
  startedAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  
  user           User         @relation(fields: [userId], references: [id])
  conversation   Conversation @relation(fields: [conversationId], references: [id])
}

/// Notification pour un utilisateur
model Notification {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  userId    String    @db.ObjectId
  /// new_conversation, new_message, message_edited, friend_request, etc.
  type      String
  title     String
  content   String
  data      String?
  priority  String    @default("normal")
  isRead    Boolean   @default(false)
  emailSent Boolean   @default(false)
  pushSent  Boolean   @default(false)
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  
  user      User      @relation(fields: [userId], references: [id])
}

/// Communaut√© (repr√©sente une communaut√© de conversation)
model Community {
  id          String        @id @default(auto()) @map("_id") @db.ObjectId
  /// Identifiant lisible par l'homme (ex: "mshy_meeshy-paris", "mshy_support-lycee-njanda")
  identifier             String                 @unique
  name        String
  description String?
  avatar      String?
  isPrivate   Boolean       @default(true)
  createdBy   String        @db.ObjectId
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  members     CommunityMember[]
  creator     User          @relation("CommunityCreator", fields: [createdBy], references: [id])
  Conversation Conversation[]
}

/// Appartenance aux communaut√©s 
model CommunityMember {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  communityId String   @db.ObjectId
  userId      String   @db.ObjectId
  joinedAt    DateTime @default(now())
  /// admin, moderator, member
  role             String       @default("member")

  user        User     @relation(fields: [userId], references: [id])
  community   Community @relation(fields: [communityId], references: [id])
}

/// Statistiques d'utilisation d'un utilisateur
model UserStats {
  id                       String   @id @default(auto()) @map("_id") @db.ObjectId
  userId                   String   @unique @db.ObjectId
  messagesSent             Int      @default(0)
  messagesReceived         Int      @default(0)
  charactersTyped          Int      @default(0)
  imageMessagesSent        Int      @default(0)
  filesShared              Int      @default(0)
  conversationsJoined      Int      @default(0)
  communitiesCreated       Int      @default(0)
  friendsAdded             Int      @default(0)
  friendRequestsSent       Int      @default(0)
  translationsUsed         Int      @default(0)
  languagesDetected        Int      @default(0)
  autoTranslateTimeMinutes Int      @default(0)
  totalOnlineTimeMinutes   Int      @default(0)
  sessionCount             Int      @default(0)
  lastActiveAt             DateTime @default(now())
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt
  
  user                     User     @relation(fields: [userId], references: [id])
}

/// Pr√©f√©rence utilisateur g√©n√©rale
model UserPreference {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  userId      String   @db.ObjectId
  key         String
  value       String
  valueType   String   @default("string")
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id])
}

/// Pr√©f√©rence sp√©cifique √† une conversation
model ConversationPreference {
  id             String       @id @default(auto()) @map("_id") @db.ObjectId
  conversationId String       @db.ObjectId
  userId         String       @db.ObjectId
  key            String
  value          String
  valueType      String       @default("string")
  description    String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  
  user           User         @relation(fields: [userId], references: [id])
  conversation   Conversation @relation(fields: [conversationId], references: [id])
}

/// Token d'affiliation pour inviter des utilisateurs
model AffiliateToken {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  token       String   @unique
  name        String   // Nom de la campagne d'affiliation
  createdBy   String   @db.ObjectId
  maxUses     Int?     // Limite d'utilisation (null = illimit√©)
  currentUses Int      @default(0)
  expiresAt   DateTime? // Date d'expiration (null = pas d'expiration)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  creator     User     @relation("AffiliateTokenCreator", fields: [createdBy], references: [id])
  affiliations AffiliateRelation[]
}

/// Relation d'affiliation entre utilisateurs
model AffiliateRelation {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  affiliateTokenId String   @db.ObjectId
  affiliateUserId  String   @db.ObjectId // Utilisateur qui a invit√©
  referredUserId   String   @db.ObjectId // Utilisateur invit√©
  status          String   @default("pending") // pending, completed, expired
  createdAt       DateTime @default(now())
  completedAt     DateTime? // Date de finalisation de l'inscription
  
  affiliateToken  AffiliateToken @relation(fields: [affiliateTokenId], references: [id])
  affiliateUser   User           @relation("AffiliateUser", fields: [affiliateUserId], references: [id])
  referredUser    User           @relation("ReferredUser", fields: [referredUserId], references: [id])
}

/// Lien de tracking pour compter les clics sur les liens partag√©s
model TrackingLink {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  token           String   @unique // Token de 6 caract√®res (ex: "a1b2c3")
  name            String?  // Nom du lien (max 32 caract√®res)
  originalUrl     String   // URL originale compl√®te
  shortUrl        String   // URL courte g√©n√©r√©e (meeshy.me/l/<token>)
  createdBy       String?  @db.ObjectId // Utilisateur qui a cr√©√© le lien (null si anonyme)
  conversationId  String?  @db.ObjectId // Conversation o√π le lien a √©t√© partag√©
  messageId       String?  @db.ObjectId // Message contenant le lien
  totalClicks     Int      @default(0) // Nombre total de clics
  uniqueClicks    Int      @default(0) // Nombre de clics uniques (par IP/fingerprint)
  isActive        Boolean  @default(true) // Le lien est-il actif
  expiresAt       DateTime? // Date d'expiration (null = pas d'expiration)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  lastClickedAt   DateTime? // Date du dernier clic
  
  clicks          TrackingLinkClick[]
  creator         User?    @relation("TrackingLinkCreator", fields: [createdBy], references: [id])
}

/// Clic sur un lien de tracking
model TrackingLinkClick {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  trackingLinkId  String   @db.ObjectId
  userId          String?  @db.ObjectId // Utilisateur connect√© qui a cliqu√© (null si anonyme)
  anonymousId     String?  @db.ObjectId // Participant anonyme qui a cliqu√©
  ipAddress       String?  // Adresse IP du visiteur
  country         String?  // Pays d'origine
  city            String?  // Ville
  region          String?  // R√©gion
  userAgent       String?  // User agent du navigateur
  browser         String?  // Navigateur d√©tect√©
  os              String?  // Syst√®me d'exploitation
  device          String?  // Type d'appareil (mobile, desktop, tablet)
  language        String?  // Langue du navigateur
  referrer        String?  // Page d'origine
  deviceFingerprint String? // Empreinte unique du device
  clickedAt       DateTime @default(now())
  
  trackingLink    TrackingLink @relation(fields: [trackingLinkId], references: [id])
  user            User?        @relation("TrackingLinkClickUser", fields: [userId], references: [id])
  anonymousUser   AnonymousParticipant? @relation("TrackingLinkClickAnonymous", fields: [anonymousId], references: [id])
}

/// Journal d'audit des actions administratives
model AdminAuditLog {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  /// ID de l'utilisateur affect√© par l'action
  userId      String    @db.ObjectId
  /// ID de l'administrateur qui a effectu√© l'action
  adminId     String    @db.ObjectId
  /// Type d'action (VIEW_USER, CREATE_USER, UPDATE_PROFILE, etc.)
  action      String
  /// Type d'entit√© affect√©e (User, Community, etc.)
  entity      String    @default("User")
  /// ID de l'entit√© affect√©e
  entityId    String
  /// Changements effectu√©s (JSON stringifi√©)
  changes     String?
  /// M√©tadonn√©es suppl√©mentaires (JSON stringifi√©)
  metadata    String?
  /// Adresse IP de l'admin
  ipAddress   String?
  /// User agent du navigateur
  userAgent   String?
  /// Date de cr√©ation du log
  createdAt   DateTime  @default(now())

  @@index([adminId])
  @@index([userId])
  @@index([action])
  @@index([createdAt])
}

/// Signalement de contenu inappropri√©
model Report {
  id                String    @id @default(auto()) @map("_id") @db.ObjectId
  /// Type de contenu signal√©: message, user, conversation, community
  reportedType      String
  /// ID de l'entit√© signal√©e
  reportedEntityId  String    @db.ObjectId
  /// ID de l'utilisateur qui signale (null si anonyme)
  reporterId        String?   @db.ObjectId
  /// Nom de l'utilisateur anonyme qui signale
  reporterName      String?
  /// Type de signalement: spam, inappropriate, harassment, violence, hate_speech, other
  reportType        String
  /// Raison d√©taill√©e du signalement
  reason            String?
  /// Statut: pending, under_review, resolved, rejected, dismissed
  status            String    @default("pending")
  /// ID du mod√©rateur qui traite le signalement
  moderatorId       String?   @db.ObjectId
  /// Notes du mod√©rateur
  moderatorNotes    String?
  /// Action prise: none, warning_sent, content_removed, user_suspended, user_banned
  actionTaken       String?
  /// Date de cr√©ation du signalement
  createdAt         DateTime  @default(now())
  /// Date de mise √† jour
  updatedAt         DateTime  @updatedAt
  /// Date de r√©solution
  resolvedAt        DateTime?

  @@index([reportedType])
  @@index([reportedEntityId])
  @@index([reporterId])
  @@index([status])
  @@index([reportType])
  @@index([createdAt])
  @@index([resolvedAt])
}

// ============================================
// VIDEO CALLS FEATURE - PHASE 1A: P2P MVP
// ============================================

/// Call Session - Represents an active or completed video call
model CallSession {
  id              String           @id @default(auto()) @map("_id") @db.ObjectId
  conversationId  String           @db.ObjectId
  conversation    Conversation     @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  /// Call mode: p2p for 2 participants, sfu for 3+
  mode            CallMode         @default(p2p)

  /// Call status: initiated, ringing, active, ended
  status          CallStatus       @default(initiated)

  /// User who initiated the call
  initiatorId     String           @db.ObjectId
  initiator       User             @relation("CallInitiator", fields: [initiatorId], references: [id])

  /// Timestamps
  startedAt       DateTime         @default(now())
  answeredAt      DateTime?        // When first participant answered
  endedAt         DateTime?
  duration        Int?             // Duration in seconds

  /// Participants in this call
  participants    CallParticipant[]

  /// Transcriptions (Phase 2A/2B)
  transcriptions  Transcription[]

  /// Call metadata
  metadata        Json?            // { maxParticipants, recordingEnabled, etc. }

  /// Indexes
  @@index([conversationId])
  @@index([status])
  @@index([startedAt])

  @@map("call_sessions")
}

/// Call Participant - Represents a user participating in a call
model CallParticipant {
  id              String       @id @default(auto()) @map("_id") @db.ObjectId
  callSessionId   String       @db.ObjectId
  callSession     CallSession  @relation(fields: [callSessionId], references: [id], onDelete: Cascade)

  /// Authenticated user (null for anonymous)
  userId          String?      @db.ObjectId
  user            User?        @relation("CallParticipants", fields: [userId], references: [id])

  /// Anonymous participant ID (from AnonymousParticipant model)
  anonymousId     String?

  /// Participant role: initiator or participant
  role            ParticipantRole @default(participant)

  /// Timestamps
  joinedAt        DateTime     @default(now())
  leftAt          DateTime?

  /// Media state
  isAudioEnabled  Boolean      @default(true)
  isVideoEnabled  Boolean      @default(true)

  /// Connection quality metadata
  connectionQuality Json?      // { latency, packetLoss, bandwidth }

  /// Indexes
  @@index([callSessionId])
  @@index([userId])

  @@map("call_participants")
}

/// Transcription - Phase 2A/2B (prepared for future)
/// Stores transcriptions from client or server
model Transcription {
  id              String       @id @default(auto()) @map("_id") @db.ObjectId
  callSessionId   String       @db.ObjectId
  callSession     CallSession  @relation(fields: [callSessionId], references: [id], onDelete: Cascade)

  /// Participant who spoke
  participantId   String       @db.ObjectId

  /// Transcription source: client (Web Speech API/Whisper.js) or server (faster-whisper)
  source          TranscriptionSource

  /// Transcribed text
  text            String

  /// Original language detected/specified
  language        String

  /// Confidence score (0-1)
  confidence      Float?

  /// Timestamp in call (milliseconds from call start)
  timestamp       DateTime     @default(now())
  offsetMs        Int?         // Offset from call start in milliseconds

  /// Translations of this transcription (Phase 3)
  translations    TranslationCall[]

  /// Indexes
  @@index([callSessionId])
  @@index([timestamp])

  @@map("transcriptions")
}

/// Translation - Phase 3 (prepared for future)
/// Stores translations of transcriptions
model TranslationCall {
  id                String        @id @default(auto()) @map("_id") @db.ObjectId
  transcriptionId   String        @db.ObjectId
  transcription     Transcription @relation(fields: [transcriptionId], references: [id], onDelete: Cascade)

  /// Target language code
  targetLanguage    String

  /// Translated text
  translatedText    String

  /// Translation confidence (0-1)
  confidence        Float?

  /// Translation model used
  model             String?      // e.g., "gpt-4", "google-translate", etc.

  /// Cached translation
  cached            Boolean      @default(false)

  /// Timestamp
  createdAt         DateTime     @default(now())

  /// Indexes
  @@index([transcriptionId])

  @@map("translation_calls")
}

/// Enums for video calls

enum CallMode {
  p2p    // Peer-to-peer (2 participants)
  sfu    // Selective Forwarding Unit (3+ participants)
}

enum CallStatus {
  initiated  // Call created, waiting for participants
  ringing    // Ringing on remote participants
  active     // Call is active with participants
  ended      // Call has ended
}

enum ParticipantRole {
  initiator    // User who started the call
  participant  // Regular participant
}

enum TranscriptionSource {
  client  // Client-side (Web Speech API or Whisper.js)
  server  // Server-side (faster-whisper)
}
