#!/bin/bash
set -e

echo "[TRANSLATOR] üöÄ D√©marrage du service Translator avec migrations Prisma..."

# Fonction pour attendre que la base de donn√©es soit pr√™te
wait_for_database() {
    echo "[TRANSLATOR] üîÑ Attente de la base de donn√©es PostgreSQL..."
    
    # Variables d'environnement pour la connexion √† la base de donn√©es
    DB_HOST=$(echo $DATABASE_URL | sed -n 's/.*@\([^:]*\):.*/\1/p')
    DB_PORT=$(echo $DATABASE_URL | sed -n 's/.*:\([0-9]*\)\/.*/\1/p')
    DB_NAME=$(echo $DATABASE_URL | sed -n 's/.*\/\([^?]*\).*/\1/p')
    DB_USER=$(echo $DATABASE_URL | sed -n 's/.*:\/\/\([^:]*\):.*/\1/p')
    DB_PASS=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p')
    echo "DATABASE_URL: $DATABASE_URL"
    # Attendre que PostgreSQL soit pr√™t
    until pg_isready -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME"; do
        echo "[TRANSLATOR] ‚è≥ Base de donn√©es non pr√™te, attente de 5 secondes..."
        sleep 5
    done
    
    echo "[TRANSLATOR] ‚úÖ Base de donn√©es PostgreSQL pr√™te"
    
    # V√©rifier si la base de donn√©es existe, sinon la cr√©er
    echo "[TRANSLATOR] üîç V√©rification de l'existence de la base de donn√©es..."
    if ! psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 1;" >/dev/null 2>&1; then
        echo "[TRANSLATOR] üÜï Base de donn√©es '$DB_NAME' n'existe pas, tentative de cr√©ation..."
        
        # Se connecter √† la base de donn√©es par d√©faut pour cr√©er la nouvelle base
        if psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "postgres" -c "CREATE DATABASE \"$DB_NAME\";" >/dev/null 2>&1; then
            echo "[TRANSLATOR] ‚úÖ Base de donn√©es '$DB_NAME' cr√©√©e avec succ√®s"
        else
            echo "[TRANSLATOR] ‚ö†Ô∏è Impossible de cr√©er la base de donn√©es, elle sera cr√©√©e par Prisma"
        fi
    else
        echo "[TRANSLATOR] ‚úÖ Base de donn√©es '$DB_NAME' existe d√©j√†"
    fi
}

# Fonction pour ex√©cuter les migrations Prisma
run_prisma_migrations() {
    echo "[TRANSLATOR] üîß Initialisation et migrations de la base de donn√©es..."
    
    # Afficher les variables d'environnement pour debug
    echo "[TRANSLATOR] üîß Variables d'environnement:"
    env | grep -E "(PRISMA|DATABASE|PYTHON)" | sort
    
    # V√©rifier le client Prisma
    echo "[TRANSLATOR] üì¶ V√©rification du client Prisma..."
    if [ -d "/usr/local/lib/python3.12/site-packages/prisma" ]; then
        echo "[TRANSLATOR] ‚úÖ Client Prisma trouv√© dans /usr/local/lib/python3.12/site-packages/prisma"
    else
        echo "[TRANSLATOR] üîß G√©n√©ration du client Prisma..."
        cd /app/generated
        if prisma generate --schema=/app/shared/prisma/schema.prisma; then
            cp -rf /usr/local/lib/python3.12/site-packages/prisma /app/generated/
            echo "[TRANSLATOR] ‚úÖ Client Prisma g√©n√©r√©"
        else
            echo "[TRANSLATOR] ‚ö†Ô∏è √âchec g√©n√©ration client - continuation..."
        fi
        cd /app
    fi
     
    # V√©rifier si la base de donn√©es existe et a des tables
    echo "[TRANSLATOR] üîç V√©rification de l'√©tat de la base de donn√©es..."
    
    # Initialisation et migration de la base de donn√©es
    echo "[TRANSLATOR] üóÑÔ∏è Initialisation et migration de la base de donn√©es..."
    python3 -c "
import asyncio
import os
import subprocess
import sys

# Ajouter le r√©pertoire g√©n√©r√© au path Python
sys.path.insert(0, '/app/generated')

async def init_database():
    try:
        # Essayer d'abord avec db push (plus rapide pour l'initialisation)
        try:
            print('[TRANSLATOR] üîß Application du sch√©ma avec prisma db push...')
            result = subprocess.run([
                'prisma', 'db', 'push', 
                '--schema=./shared/prisma/schema.prisma', 
                '--accept-data-loss'
            ], capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0:
                print('[TRANSLATOR] ‚úÖ Sch√©ma de base de donn√©es appliqu√© avec db push')
                return True
            else:
                print(f'[TRANSLATOR] ‚ö†Ô∏è db push √©chou√©: {result.stderr}')
                raise Exception('db push failed')
                
        except Exception as e:
            print(f'[TRANSLATOR] ‚ö†Ô∏è Fallback vers migrate deploy: {e}')
            
            # Fallback vers migrate deploy
            try:
                print('[TRANSLATOR] üîß Application des migrations avec prisma migrate deploy...')
                result = subprocess.run([
                    'prisma', 'migrate', 'deploy', 
                    '--schema=./shared/prisma/schema.prisma'
                ], capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0:
                    print('[TRANSLATOR] ‚úÖ Migrations appliqu√©es avec migrate deploy')
                    return True
                else:
                    print(f'[TRANSLATOR] ‚ùå migrate deploy √©chou√©: {result.stderr}')
                    return False
                    
            except Exception as e2:
                print(f'[TRANSLATOR] ‚ùå √âchec du fallback: {e2}')
                return False
                
    except Exception as e:
        print(f'[TRANSLATOR] ‚ùå Erreur lors de l\'initialisation: {e}')
        return False

if asyncio.run(init_database()):
    print('[TRANSLATOR] ‚úÖ Initialisation de la base de donn√©es r√©ussie')
else:
    print('[TRANSLATOR] ‚ùå √âchec de l\'initialisation de la base de donn√©es')
    exit(1)
"
    
    echo "[TRANSLATOR] ‚úÖ Initialisation et migrations Prisma termin√©es avec succ√®s"
}

# Fonction pour v√©rifier l'int√©grit√© de la base de donn√©es
check_database_integrity() {
    echo "[TRANSLATOR] üîç V√©rification de l'int√©grit√© de la base de donn√©es..."
    
# V√©rifier que les tables principales existent et sont accessibles
python3 -c "
import asyncio
import os
import sys

# Ajouter le r√©pertoire g√©n√©r√© au path Python
sys.path.insert(0, '/app/generated')

try:
    from prisma import Prisma
    
    async def check_db():
        try:
            db = Prisma()
            await db.connect()
            print('[TRANSLATOR] ‚úÖ Base de donn√©es connect√©e')
            # Liste des tables principales √† v√©rifier
            main_tables = [
                'users',
                'conversations', 
                'messages',
                'message_translations',
                'communities',
                'conversation_members',
                'community_members',
                'user_preferences',
                'notifications'
            ]
            
            print('[TRANSLATOR] üîç V√©rification des tables principales...')
            
            for table in main_tables:
                try:
                    print(f'[TRANSLATOR] üîç V√©rification de la table {table}...')
                    # Utiliser query_raw au lieu de execute_raw pour les SELECT
                    result = await db.query_raw(f'SELECT COUNT(*) as count FROM \"{table}\"')
                    
                    # G√©rer diff√©rents formats de r√©sultat
                    if isinstance(result, list) and len(result) > 0:
                        if isinstance(result[0], dict):
                            count = result[0].get('count', 0)
                        else:
                            count = result[0]
                    elif isinstance(result, int):
                        count = result
                    else:
                        count = 0
                        
                    print(f'[TRANSLATOR] ‚úÖ Table {table} accessible ({count} enregistrements)')
                except Exception as e:
                    print(f'[TRANSLATOR] ‚ö†Ô∏è Table {table} non accessible: {e}')
                    # Ne pas arr√™ter pour une seule table, continuer avec les autres
                    continue
            
            # V√©rifier les index et contraintes de mani√®re plus robuste
            print('[TRANSLATOR] üîç V√©rification des index et contraintes...')
            
            try:
                # V√©rifier que les index principaux existent
                indexes = await db.query_raw(\"\"\"
                    SELECT indexname, tablename 
                    FROM pg_indexes 
                    WHERE schemaname = 'public' 
                    AND indexname LIKE '%_pkey'
                \"\"\")
                
                if indexes and len(indexes) > 0:
                    print(f'[TRANSLATOR] ‚úÖ {len(indexes)} index primaires trouv√©s')
                else:
                    print('[TRANSLATOR] ‚ö†Ô∏è Aucun index primaire trouv√©')
            except Exception as e:
                print(f'[TRANSLATOR] ‚ö†Ô∏è Erreur lors de la v√©rification des index: {e}')
            
            await db.disconnect()
            return True
        except Exception as e:
            print(f'[TRANSLATOR] ‚ùå Erreur de v√©rification de la base de donn√©es: {e}')
            return False

    if asyncio.run(check_db()):
        print('[TRANSLATOR] ‚úÖ Int√©grit√© de la base de donn√©es v√©rifi√©e')
    else:
        print('[TRANSLATOR] ‚ö†Ô∏è Probl√®me avec l\'int√©grit√© de la base de donn√©es, mais continuons...')
        # Ne pas arr√™ter l'application pour des probl√®mes de v√©rification
        
except ImportError:
    print('[TRANSLATOR] ‚ö†Ô∏è Client Prisma non disponible, v√©rification d\'int√©grit√© ignor√©e')
    print('[TRANSLATOR] ‚úÖ Initialisation termin√©e sans v√©rification d\'int√©grit√©')
"
}

# Fonction principale
main() {
    echo "[TRANSLATOR] üéØ D√©marrage du processus d'initialisation..."
    
    # Attendre que la base de donn√©es soit pr√™te
    wait_for_database
    
    # Ex√©cuter les migrations Prisma
    run_prisma_migrations
    
    # V√©rifier l'int√©grit√© de la base de donn√©es
    check_database_integrity
    
    echo "[TRANSLATOR] üöÄ D√©marrage de l'application Translator..."
    
    # D√©marrer l'application Python
    exec python3 -u src/main.py
}

# Ex√©cuter la fonction principale
main
