# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'username': 'bbadfchfja',
                'firstName': 'dhheabfhf',
                'lastName': 'ggciceaie',
                'email': 'bbehjachib',
                'password': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'username': 'dgiiaaijj',
                    'firstName': 'bfaiacjjfc',
                    'lastName': 'eigcfgbif',
                    'email': 'bagcfbhiig',
                    'password': 'cghideieh',
                },
                {
                    # data to create a User record
                    'username': 'biabhbdai',
                    'firstName': 'idghgaicb',
                    'lastName': 'fjfddhigg',
                    'email': 'hjaecfifb',
                    'password': 'cbbbjbfcii',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'bbejhfidcb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'bgeecijdgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'bdiicjafbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the id field
        users = await User.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the username field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the firstName field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'firstName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'bgehebiafc',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bghffegacj',
            },
            data={
                'create': {
                    'id': 'bghffegacj',
                    'username': 'biabhbdai',
                    'firstName': 'idghgaicb',
                    'lastName': 'fjfddhigg',
                    'email': 'hjaecfifb',
                    'password': 'cbbbjbfcii',
                },
                'update': {
                    'username': 'biabhbdai',
                    'firstName': 'idghgaicb',
                    'lastName': 'fjfddhigg',
                    'email': 'hjaecfifb',
                    'password': 'cbbbjbfcii',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'lastName': 'bhghchehcc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'email': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'phoneNumber': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by password values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['password'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ConversationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.ConversationCreateInput,
        include: Optional[types.ConversationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Conversation record.

        Parameters
        ----------
        data
            Conversation record data
        include
            Specifies which relations should be loaded on the returned Conversation model

        Returns
        -------
        prisma.models.Conversation
            The created Conversation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Conversation record from just the required fields
        conversation = await Conversation.prisma().create(
            data={
                # data to create a Conversation record
                'type': 'dcgchcbbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ConversationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Conversation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Conversation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Conversation.prisma().create_many(
            data=[
                {
                    # data to create a Conversation record
                    'type': 'bdedcabahc',
                },
                {
                    # data to create a Conversation record
                    'type': 'ghfhiafcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ConversationWhereUniqueInput,
        include: Optional[types.ConversationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Conversation record.

        Parameters
        ----------
        where
            Conversation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Conversation model

        Returns
        -------
        prisma.models.Conversation
            The deleted Conversation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversation = await Conversation.prisma().delete(
            where={
                'id': 'heejgedji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ConversationWhereUniqueInput,
        include: Optional[types.ConversationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Conversation record.

        Parameters
        ----------
        where
            Conversation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Conversation model

        Returns
        -------
        prisma.models.Conversation
            The found Conversation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversation = await Conversation.prisma().find_unique(
            where={
                'id': 'bjgjgibgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ConversationWhereUniqueInput,
        include: Optional[types.ConversationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Conversation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Conversation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Conversation model

        Returns
        -------
        prisma.models.Conversation
            The found Conversation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversation = await Conversation.prisma().find_unique_or_raise(
            where={
                'id': 'bbbgbhfjge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationWhereInput] = None,
        cursor: Optional[types.ConversationWhereUniqueInput] = None,
        include: Optional[types.ConversationInclude] = None,
        order: Optional[Union[types.ConversationOrderByInput, List[types.ConversationOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Conversation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Conversation records returned
        skip
            Ignore the first N results
        where
            Conversation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Conversation model
        order
            Order the returned Conversation records by any field
        distinct
            Filter Conversation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Conversation]
            The list of all Conversation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Conversation records
        conversations = await Conversation.prisma().find_many(take=10)

        # find the first 5 Conversation records ordered by the id field
        conversations = await Conversation.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationWhereInput] = None,
        cursor: Optional[types.ConversationWhereUniqueInput] = None,
        include: Optional[types.ConversationInclude] = None,
        order: Optional[Union[types.ConversationOrderByInput, List[types.ConversationOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Conversation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Conversation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Conversation model
        order
            Order the returned Conversation records by any field
        distinct
            Filter Conversation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Conversation
            The first Conversation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Conversation record ordered by the identifier field
        conversation = await Conversation.prisma().find_first(
            skip=1,
            order={
                'identifier': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationWhereInput] = None,
        cursor: Optional[types.ConversationWhereUniqueInput] = None,
        include: Optional[types.ConversationInclude] = None,
        order: Optional[Union[types.ConversationOrderByInput, List[types.ConversationOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Conversation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Conversation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Conversation model
        order
            Order the returned Conversation records by any field
        distinct
            Filter Conversation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Conversation
            The first Conversation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Conversation record ordered by the type field
        conversation = await Conversation.prisma().find_first_or_raise(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ConversationUpdateInput,
        where: types.ConversationWhereUniqueInput,
        include: Optional[types.ConversationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Conversation record.

        Parameters
        ----------
        data
            Conversation record data specifying what to update
        where
            Conversation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Conversation model

        Returns
        -------
        prisma.models.Conversation
            The updated Conversation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        conversation = await Conversation.prisma().update(
            where={
                'id': 'igbehcbab',
            },
            data={
                # data to update the Conversation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ConversationWhereUniqueInput,
        data: types.ConversationUpsertInput,
        include: Optional[types.ConversationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Conversation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Conversation model

        Returns
        -------
        prisma.models.Conversation
            The created or updated Conversation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversation = await Conversation.prisma().upsert(
            where={
                'id': 'bdadaadhag',
            },
            data={
                'create': {
                    'id': 'bdadaadhag',
                    'type': 'ghfhiafcb',
                },
                'update': {
                    'type': 'ghfhiafcb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ConversationUpdateManyMutationInput,
        where: types.ConversationWhereInput,
    ) -> int:
        """Update multiple Conversation records

        Parameters
        ----------
        data
            Conversation data to update the selected Conversation records to
        where
            Filter to select the Conversation records to update

        Returns
        -------
        int
            The total number of Conversation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Conversation records
        total = await Conversation.prisma().update_many(
            data={
                'title': 'bgiggdidbf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationWhereInput] = None,
        cursor: Optional[types.ConversationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Conversation records present in the database

        Parameters
        ----------
        select
            Select the Conversation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Conversation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Conversation.prisma().count()

        # results: prisma.types.ConversationCountAggregateOutput
        results = await Conversation.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ConversationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationWhereInput] = None,
        cursor: Optional[types.ConversationWhereUniqueInput] = None,
    ) -> types.ConversationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ConversationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationWhereInput] = None,
        cursor: Optional[types.ConversationWhereUniqueInput] = None,
    ) -> Union[int, types.ConversationCountAggregateOutput]:
        """Count the number of Conversation records present in the database

        Parameters
        ----------
        select
            Select the Conversation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Conversation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Conversation.prisma().count()

        # results: prisma.types.ConversationCountAggregateOutput
        results = await Conversation.prisma().count(
            select={
                '_all': True,
                'image': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ConversationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ConversationWhereInput] = None
    ) -> int:
        """Delete multiple Conversation records.

        Parameters
        ----------
        where
            Optional Conversation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Conversation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Conversation records
        total = await Conversation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ConversationScalarFieldKeys'],
        *,
        where: Optional['types.ConversationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ConversationAvgAggregateInput'] = None,
        sum: Optional['types.ConversationSumAggregateInput'] = None,
        min: Optional['types.ConversationMinAggregateInput'] = None,
        max: Optional['types.ConversationMaxAggregateInput'] = None,
        having: Optional['types.ConversationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ConversationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ConversationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ConversationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ConversationGroupByOutput']:
        """Group Conversation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Conversation fields to group records by
        where
            Conversation filter to select records
        take
            Limit the maximum number of Conversation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ConversationGroupByOutput]
            A list of dictionaries representing the Conversation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Conversation records by avatar values
        # and count how many records are in each group
        results = await Conversation.prisma().group_by(
            ['avatar'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ConversationMemberActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.ConversationMemberCreateInput,
        include: Optional[types.ConversationMemberInclude] = None
    ) -> _PrismaModelT:
        """Create a new ConversationMember record.

        Parameters
        ----------
        data
            ConversationMember record data
        include
            Specifies which relations should be loaded on the returned ConversationMember model

        Returns
        -------
        prisma.models.ConversationMember
            The created ConversationMember record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ConversationMember record from just the required fields
        conversationmember = await ConversationMember.prisma().create(
            data={
                # data to create a ConversationMember record
                'conversationId': 'caaaedabfc',
                'userId': 'bigibebcib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ConversationMemberCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ConversationMember records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ConversationMember record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ConversationMember.prisma().create_many(
            data=[
                {
                    # data to create a ConversationMember record
                    'conversationId': 'bigaiehgcc',
                    'userId': 'beeifcbebf',
                },
                {
                    # data to create a ConversationMember record
                    'conversationId': 'bgcigfahea',
                    'userId': 'bcejgaggif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ConversationMemberWhereUniqueInput,
        include: Optional[types.ConversationMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ConversationMember record.

        Parameters
        ----------
        where
            ConversationMember filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationMember model

        Returns
        -------
        prisma.models.ConversationMember
            The deleted ConversationMember record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationmember = await ConversationMember.prisma().delete(
            where={
                'id': 'idfjadbcc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ConversationMemberWhereUniqueInput,
        include: Optional[types.ConversationMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ConversationMember record.

        Parameters
        ----------
        where
            ConversationMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationMember model

        Returns
        -------
        prisma.models.ConversationMember
            The found ConversationMember record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationmember = await ConversationMember.prisma().find_unique(
            where={
                'id': 'hgdhbjhhj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ConversationMemberWhereUniqueInput,
        include: Optional[types.ConversationMemberInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ConversationMember record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ConversationMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationMember model

        Returns
        -------
        prisma.models.ConversationMember
            The found ConversationMember record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationmember = await ConversationMember.prisma().find_unique_or_raise(
            where={
                'id': 'ecjjjfbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationMemberWhereInput] = None,
        cursor: Optional[types.ConversationMemberWhereUniqueInput] = None,
        include: Optional[types.ConversationMemberInclude] = None,
        order: Optional[Union[types.ConversationMemberOrderByInput, List[types.ConversationMemberOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationMemberScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ConversationMember records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ConversationMember records returned
        skip
            Ignore the first N results
        where
            ConversationMember filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationMember model
        order
            Order the returned ConversationMember records by any field
        distinct
            Filter ConversationMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ConversationMember]
            The list of all ConversationMember records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ConversationMember records
        conversationmembers = await ConversationMember.prisma().find_many(take=10)

        # find the first 5 ConversationMember records ordered by the id field
        conversationmembers = await ConversationMember.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationMemberWhereInput] = None,
        cursor: Optional[types.ConversationMemberWhereUniqueInput] = None,
        include: Optional[types.ConversationMemberInclude] = None,
        order: Optional[Union[types.ConversationMemberOrderByInput, List[types.ConversationMemberOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationMemberScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ConversationMember record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ConversationMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationMember model
        order
            Order the returned ConversationMember records by any field
        distinct
            Filter ConversationMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ConversationMember
            The first ConversationMember record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ConversationMember record ordered by the conversationId field
        conversationmember = await ConversationMember.prisma().find_first(
            skip=1,
            order={
                'conversationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationMemberWhereInput] = None,
        cursor: Optional[types.ConversationMemberWhereUniqueInput] = None,
        include: Optional[types.ConversationMemberInclude] = None,
        order: Optional[Union[types.ConversationMemberOrderByInput, List[types.ConversationMemberOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationMemberScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ConversationMember record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ConversationMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationMember model
        order
            Order the returned ConversationMember records by any field
        distinct
            Filter ConversationMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ConversationMember
            The first ConversationMember record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ConversationMember record ordered by the userId field
        conversationmember = await ConversationMember.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ConversationMemberUpdateInput,
        where: types.ConversationMemberWhereUniqueInput,
        include: Optional[types.ConversationMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ConversationMember record.

        Parameters
        ----------
        data
            ConversationMember record data specifying what to update
        where
            ConversationMember filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ConversationMember model

        Returns
        -------
        prisma.models.ConversationMember
            The updated ConversationMember record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        conversationmember = await ConversationMember.prisma().update(
            where={
                'id': 'bhhfibbigf',
            },
            data={
                # data to update the ConversationMember record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ConversationMemberWhereUniqueInput,
        data: types.ConversationMemberUpsertInput,
        include: Optional[types.ConversationMemberInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ConversationMember filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ConversationMember model

        Returns
        -------
        prisma.models.ConversationMember
            The created or updated ConversationMember record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationmember = await ConversationMember.prisma().upsert(
            where={
                'id': 'ijdbeffgg',
            },
            data={
                'create': {
                    'id': 'ijdbeffgg',
                    'conversationId': 'bgcigfahea',
                    'userId': 'bcejgaggif',
                },
                'update': {
                    'conversationId': 'bgcigfahea',
                    'userId': 'bcejgaggif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ConversationMemberUpdateManyMutationInput,
        where: types.ConversationMemberWhereInput,
    ) -> int:
        """Update multiple ConversationMember records

        Parameters
        ----------
        data
            ConversationMember data to update the selected ConversationMember records to
        where
            Filter to select the ConversationMember records to update

        Returns
        -------
        int
            The total number of ConversationMember records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ConversationMember records
        total = await ConversationMember.prisma().update_many(
            data={
                'role': 'jjfeafhfj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationMemberWhereInput] = None,
        cursor: Optional[types.ConversationMemberWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ConversationMember records present in the database

        Parameters
        ----------
        select
            Select the ConversationMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ConversationMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ConversationMember.prisma().count()

        # results: prisma.types.ConversationMemberCountAggregateOutput
        results = await ConversationMember.prisma().count(
            select={
                '_all': True,
                'canSendMessage': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ConversationMemberCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationMemberWhereInput] = None,
        cursor: Optional[types.ConversationMemberWhereUniqueInput] = None,
    ) -> types.ConversationMemberCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ConversationMemberCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationMemberWhereInput] = None,
        cursor: Optional[types.ConversationMemberWhereUniqueInput] = None,
    ) -> Union[int, types.ConversationMemberCountAggregateOutput]:
        """Count the number of ConversationMember records present in the database

        Parameters
        ----------
        select
            Select the ConversationMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ConversationMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ConversationMember.prisma().count()

        # results: prisma.types.ConversationMemberCountAggregateOutput
        results = await ConversationMember.prisma().count(
            select={
                '_all': True,
                'canSendFiles': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ConversationMemberCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ConversationMemberWhereInput] = None
    ) -> int:
        """Delete multiple ConversationMember records.

        Parameters
        ----------
        where
            Optional ConversationMember filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ConversationMember records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ConversationMember records
        total = await ConversationMember.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ConversationMemberScalarFieldKeys'],
        *,
        where: Optional['types.ConversationMemberWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ConversationMemberAvgAggregateInput'] = None,
        sum: Optional['types.ConversationMemberSumAggregateInput'] = None,
        min: Optional['types.ConversationMemberMinAggregateInput'] = None,
        max: Optional['types.ConversationMemberMaxAggregateInput'] = None,
        having: Optional['types.ConversationMemberScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ConversationMemberCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ConversationMemberScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ConversationMemberScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ConversationMemberGroupByOutput']:
        """Group ConversationMember records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ConversationMember fields to group records by
        where
            ConversationMember filter to select records
        take
            Limit the maximum number of ConversationMember records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ConversationMemberGroupByOutput]
            A list of dictionaries representing the ConversationMember record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ConversationMember records by canSendImages values
        # and count how many records are in each group
        results = await ConversationMember.prisma().group_by(
            ['canSendImages'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ConversationShareLinkActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.ConversationShareLinkCreateInput,
        include: Optional[types.ConversationShareLinkInclude] = None
    ) -> _PrismaModelT:
        """Create a new ConversationShareLink record.

        Parameters
        ----------
        data
            ConversationShareLink record data
        include
            Specifies which relations should be loaded on the returned ConversationShareLink model

        Returns
        -------
        prisma.models.ConversationShareLink
            The created ConversationShareLink record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ConversationShareLink record from just the required fields
        conversationsharelink = await ConversationShareLink.prisma().create(
            data={
                # data to create a ConversationShareLink record
                'linkId': 'cbachdgfce',
                'conversationId': 'chbfcacbd',
                'createdBy': 'efggddide',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ConversationShareLinkCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ConversationShareLink records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ConversationShareLink record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ConversationShareLink.prisma().create_many(
            data=[
                {
                    # data to create a ConversationShareLink record
                    'linkId': 'caficfigfb',
                    'conversationId': 'bfidgijfjc',
                    'createdBy': 'ihieecagf',
                },
                {
                    # data to create a ConversationShareLink record
                    'linkId': 'bghfciaafe',
                    'conversationId': 'bgchfhgceh',
                    'createdBy': 'cafeiaccbc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ConversationShareLinkWhereUniqueInput,
        include: Optional[types.ConversationShareLinkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ConversationShareLink record.

        Parameters
        ----------
        where
            ConversationShareLink filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationShareLink model

        Returns
        -------
        prisma.models.ConversationShareLink
            The deleted ConversationShareLink record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationsharelink = await ConversationShareLink.prisma().delete(
            where={
                'id': 'gaddfhfh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ConversationShareLinkWhereUniqueInput,
        include: Optional[types.ConversationShareLinkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ConversationShareLink record.

        Parameters
        ----------
        where
            ConversationShareLink filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationShareLink model

        Returns
        -------
        prisma.models.ConversationShareLink
            The found ConversationShareLink record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationsharelink = await ConversationShareLink.prisma().find_unique(
            where={
                'id': 'gieegcbeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ConversationShareLinkWhereUniqueInput,
        include: Optional[types.ConversationShareLinkInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ConversationShareLink record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ConversationShareLink filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationShareLink model

        Returns
        -------
        prisma.models.ConversationShareLink
            The found ConversationShareLink record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationsharelink = await ConversationShareLink.prisma().find_unique_or_raise(
            where={
                'id': 'bgcffadich',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationShareLinkWhereInput] = None,
        cursor: Optional[types.ConversationShareLinkWhereUniqueInput] = None,
        include: Optional[types.ConversationShareLinkInclude] = None,
        order: Optional[Union[types.ConversationShareLinkOrderByInput, List[types.ConversationShareLinkOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationShareLinkScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ConversationShareLink records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ConversationShareLink records returned
        skip
            Ignore the first N results
        where
            ConversationShareLink filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationShareLink model
        order
            Order the returned ConversationShareLink records by any field
        distinct
            Filter ConversationShareLink records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ConversationShareLink]
            The list of all ConversationShareLink records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ConversationShareLink records
        conversationsharelinks = await ConversationShareLink.prisma().find_many(take=10)

        # find the first 5 ConversationShareLink records ordered by the id field
        conversationsharelinks = await ConversationShareLink.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationShareLinkWhereInput] = None,
        cursor: Optional[types.ConversationShareLinkWhereUniqueInput] = None,
        include: Optional[types.ConversationShareLinkInclude] = None,
        order: Optional[Union[types.ConversationShareLinkOrderByInput, List[types.ConversationShareLinkOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationShareLinkScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ConversationShareLink record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ConversationShareLink filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationShareLink model
        order
            Order the returned ConversationShareLink records by any field
        distinct
            Filter ConversationShareLink records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ConversationShareLink
            The first ConversationShareLink record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ConversationShareLink record ordered by the linkId field
        conversationsharelink = await ConversationShareLink.prisma().find_first(
            skip=1,
            order={
                'linkId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationShareLinkWhereInput] = None,
        cursor: Optional[types.ConversationShareLinkWhereUniqueInput] = None,
        include: Optional[types.ConversationShareLinkInclude] = None,
        order: Optional[Union[types.ConversationShareLinkOrderByInput, List[types.ConversationShareLinkOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationShareLinkScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ConversationShareLink record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ConversationShareLink filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationShareLink model
        order
            Order the returned ConversationShareLink records by any field
        distinct
            Filter ConversationShareLink records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ConversationShareLink
            The first ConversationShareLink record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ConversationShareLink record ordered by the identifier field
        conversationsharelink = await ConversationShareLink.prisma().find_first_or_raise(
            skip=1,
            order={
                'identifier': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ConversationShareLinkUpdateInput,
        where: types.ConversationShareLinkWhereUniqueInput,
        include: Optional[types.ConversationShareLinkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ConversationShareLink record.

        Parameters
        ----------
        data
            ConversationShareLink record data specifying what to update
        where
            ConversationShareLink filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ConversationShareLink model

        Returns
        -------
        prisma.models.ConversationShareLink
            The updated ConversationShareLink record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        conversationsharelink = await ConversationShareLink.prisma().update(
            where={
                'id': 'fcbichhci',
            },
            data={
                # data to update the ConversationShareLink record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ConversationShareLinkWhereUniqueInput,
        data: types.ConversationShareLinkUpsertInput,
        include: Optional[types.ConversationShareLinkInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ConversationShareLink filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ConversationShareLink model

        Returns
        -------
        prisma.models.ConversationShareLink
            The created or updated ConversationShareLink record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationsharelink = await ConversationShareLink.prisma().upsert(
            where={
                'id': 'bcggadccgf',
            },
            data={
                'create': {
                    'id': 'bcggadccgf',
                    'linkId': 'bghfciaafe',
                    'conversationId': 'bgchfhgceh',
                    'createdBy': 'cafeiaccbc',
                },
                'update': {
                    'linkId': 'bghfciaafe',
                    'conversationId': 'bgchfhgceh',
                    'createdBy': 'cafeiaccbc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ConversationShareLinkUpdateManyMutationInput,
        where: types.ConversationShareLinkWhereInput,
    ) -> int:
        """Update multiple ConversationShareLink records

        Parameters
        ----------
        data
            ConversationShareLink data to update the selected ConversationShareLink records to
        where
            Filter to select the ConversationShareLink records to update

        Returns
        -------
        int
            The total number of ConversationShareLink records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ConversationShareLink records
        total = await ConversationShareLink.prisma().update_many(
            data={
                'conversationId': 'jdcfdcgc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationShareLinkWhereInput] = None,
        cursor: Optional[types.ConversationShareLinkWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ConversationShareLink records present in the database

        Parameters
        ----------
        select
            Select the ConversationShareLink fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ConversationShareLink filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationShareLinkCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ConversationShareLink.prisma().count()

        # results: prisma.types.ConversationShareLinkCountAggregateOutput
        results = await ConversationShareLink.prisma().count(
            select={
                '_all': True,
                'createdBy': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ConversationShareLinkCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationShareLinkWhereInput] = None,
        cursor: Optional[types.ConversationShareLinkWhereUniqueInput] = None,
    ) -> types.ConversationShareLinkCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ConversationShareLinkCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationShareLinkWhereInput] = None,
        cursor: Optional[types.ConversationShareLinkWhereUniqueInput] = None,
    ) -> Union[int, types.ConversationShareLinkCountAggregateOutput]:
        """Count the number of ConversationShareLink records present in the database

        Parameters
        ----------
        select
            Select the ConversationShareLink fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ConversationShareLink filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationShareLinkCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ConversationShareLink.prisma().count()

        # results: prisma.types.ConversationShareLinkCountAggregateOutput
        results = await ConversationShareLink.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ConversationShareLinkCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ConversationShareLinkWhereInput] = None
    ) -> int:
        """Delete multiple ConversationShareLink records.

        Parameters
        ----------
        where
            Optional ConversationShareLink filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ConversationShareLink records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ConversationShareLink records
        total = await ConversationShareLink.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ConversationShareLinkScalarFieldKeys'],
        *,
        where: Optional['types.ConversationShareLinkWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ConversationShareLinkAvgAggregateInput'] = None,
        sum: Optional['types.ConversationShareLinkSumAggregateInput'] = None,
        min: Optional['types.ConversationShareLinkMinAggregateInput'] = None,
        max: Optional['types.ConversationShareLinkMaxAggregateInput'] = None,
        having: Optional['types.ConversationShareLinkScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ConversationShareLinkCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ConversationShareLinkScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ConversationShareLinkScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ConversationShareLinkGroupByOutput']:
        """Group ConversationShareLink records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ConversationShareLink fields to group records by
        where
            ConversationShareLink filter to select records
        take
            Limit the maximum number of ConversationShareLink records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ConversationShareLinkGroupByOutput]
            A list of dictionaries representing the ConversationShareLink record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ConversationShareLink records by description values
        # and count how many records are in each group
        results = await ConversationShareLink.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AnonymousParticipantActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.AnonymousParticipantCreateInput,
        include: Optional[types.AnonymousParticipantInclude] = None
    ) -> _PrismaModelT:
        """Create a new AnonymousParticipant record.

        Parameters
        ----------
        data
            AnonymousParticipant record data
        include
            Specifies which relations should be loaded on the returned AnonymousParticipant model

        Returns
        -------
        prisma.models.AnonymousParticipant
            The created AnonymousParticipant record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AnonymousParticipant record from just the required fields
        anonymousparticipant = await AnonymousParticipant.prisma().create(
            data={
                # data to create a AnonymousParticipant record
                'conversationId': 'cafdaehjid',
                'shareLinkId': 'gifdddbia',
                'firstName': 'bchehecef',
                'lastName': 'jeijcbhfe',
                'username': 'bjgejjabff',
                'sessionToken': 'bcciijbibg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AnonymousParticipantCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AnonymousParticipant records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AnonymousParticipant record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AnonymousParticipant.prisma().create_many(
            data=[
                {
                    # data to create a AnonymousParticipant record
                    'conversationId': 'cffcachfd',
                    'shareLinkId': 'bccdfhdigc',
                    'firstName': 'febcgjbfj',
                    'lastName': 'bageiegghg',
                    'username': 'faidicegb',
                    'sessionToken': 'bacecgfhbe',
                },
                {
                    # data to create a AnonymousParticipant record
                    'conversationId': 'ihcahiead',
                    'shareLinkId': 'biheheiajg',
                    'firstName': 'jbgijghgb',
                    'lastName': 'hgjcghfbi',
                    'username': 'icadbcehj',
                    'sessionToken': 'jchciaee',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AnonymousParticipantWhereUniqueInput,
        include: Optional[types.AnonymousParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AnonymousParticipant record.

        Parameters
        ----------
        where
            AnonymousParticipant filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AnonymousParticipant model

        Returns
        -------
        prisma.models.AnonymousParticipant
            The deleted AnonymousParticipant record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        anonymousparticipant = await AnonymousParticipant.prisma().delete(
            where={
                'id': 'deeificjd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AnonymousParticipantWhereUniqueInput,
        include: Optional[types.AnonymousParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AnonymousParticipant record.

        Parameters
        ----------
        where
            AnonymousParticipant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AnonymousParticipant model

        Returns
        -------
        prisma.models.AnonymousParticipant
            The found AnonymousParticipant record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        anonymousparticipant = await AnonymousParticipant.prisma().find_unique(
            where={
                'id': 'bbcbhebbda',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AnonymousParticipantWhereUniqueInput,
        include: Optional[types.AnonymousParticipantInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AnonymousParticipant record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AnonymousParticipant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AnonymousParticipant model

        Returns
        -------
        prisma.models.AnonymousParticipant
            The found AnonymousParticipant record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        anonymousparticipant = await AnonymousParticipant.prisma().find_unique_or_raise(
            where={
                'id': 'bejfijgcfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AnonymousParticipantWhereInput] = None,
        cursor: Optional[types.AnonymousParticipantWhereUniqueInput] = None,
        include: Optional[types.AnonymousParticipantInclude] = None,
        order: Optional[Union[types.AnonymousParticipantOrderByInput, List[types.AnonymousParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.AnonymousParticipantScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AnonymousParticipant records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AnonymousParticipant records returned
        skip
            Ignore the first N results
        where
            AnonymousParticipant filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AnonymousParticipant model
        order
            Order the returned AnonymousParticipant records by any field
        distinct
            Filter AnonymousParticipant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AnonymousParticipant]
            The list of all AnonymousParticipant records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AnonymousParticipant records
        anonymousparticipants = await AnonymousParticipant.prisma().find_many(take=10)

        # find the first 5 AnonymousParticipant records ordered by the id field
        anonymousparticipants = await AnonymousParticipant.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AnonymousParticipantWhereInput] = None,
        cursor: Optional[types.AnonymousParticipantWhereUniqueInput] = None,
        include: Optional[types.AnonymousParticipantInclude] = None,
        order: Optional[Union[types.AnonymousParticipantOrderByInput, List[types.AnonymousParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.AnonymousParticipantScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AnonymousParticipant record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AnonymousParticipant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AnonymousParticipant model
        order
            Order the returned AnonymousParticipant records by any field
        distinct
            Filter AnonymousParticipant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AnonymousParticipant
            The first AnonymousParticipant record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AnonymousParticipant record ordered by the conversationId field
        anonymousparticipant = await AnonymousParticipant.prisma().find_first(
            skip=1,
            order={
                'conversationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AnonymousParticipantWhereInput] = None,
        cursor: Optional[types.AnonymousParticipantWhereUniqueInput] = None,
        include: Optional[types.AnonymousParticipantInclude] = None,
        order: Optional[Union[types.AnonymousParticipantOrderByInput, List[types.AnonymousParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.AnonymousParticipantScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AnonymousParticipant record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AnonymousParticipant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AnonymousParticipant model
        order
            Order the returned AnonymousParticipant records by any field
        distinct
            Filter AnonymousParticipant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AnonymousParticipant
            The first AnonymousParticipant record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AnonymousParticipant record ordered by the shareLinkId field
        anonymousparticipant = await AnonymousParticipant.prisma().find_first_or_raise(
            skip=1,
            order={
                'shareLinkId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AnonymousParticipantUpdateInput,
        where: types.AnonymousParticipantWhereUniqueInput,
        include: Optional[types.AnonymousParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AnonymousParticipant record.

        Parameters
        ----------
        data
            AnonymousParticipant record data specifying what to update
        where
            AnonymousParticipant filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AnonymousParticipant model

        Returns
        -------
        prisma.models.AnonymousParticipant
            The updated AnonymousParticipant record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        anonymousparticipant = await AnonymousParticipant.prisma().update(
            where={
                'id': 'caifcbgii',
            },
            data={
                # data to update the AnonymousParticipant record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AnonymousParticipantWhereUniqueInput,
        data: types.AnonymousParticipantUpsertInput,
        include: Optional[types.AnonymousParticipantInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AnonymousParticipant filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AnonymousParticipant model

        Returns
        -------
        prisma.models.AnonymousParticipant
            The created or updated AnonymousParticipant record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        anonymousparticipant = await AnonymousParticipant.prisma().upsert(
            where={
                'id': 'igaibbfgj',
            },
            data={
                'create': {
                    'id': 'igaibbfgj',
                    'conversationId': 'ihcahiead',
                    'shareLinkId': 'biheheiajg',
                    'firstName': 'jbgijghgb',
                    'lastName': 'hgjcghfbi',
                    'username': 'icadbcehj',
                    'sessionToken': 'jchciaee',
                },
                'update': {
                    'conversationId': 'ihcahiead',
                    'shareLinkId': 'biheheiajg',
                    'firstName': 'jbgijghgb',
                    'lastName': 'hgjcghfbi',
                    'username': 'icadbcehj',
                    'sessionToken': 'jchciaee',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AnonymousParticipantUpdateManyMutationInput,
        where: types.AnonymousParticipantWhereInput,
    ) -> int:
        """Update multiple AnonymousParticipant records

        Parameters
        ----------
        data
            AnonymousParticipant data to update the selected AnonymousParticipant records to
        where
            Filter to select the AnonymousParticipant records to update

        Returns
        -------
        int
            The total number of AnonymousParticipant records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AnonymousParticipant records
        total = await AnonymousParticipant.prisma().update_many(
            data={
                'firstName': 'bggajdcbbi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AnonymousParticipantWhereInput] = None,
        cursor: Optional[types.AnonymousParticipantWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AnonymousParticipant records present in the database

        Parameters
        ----------
        select
            Select the AnonymousParticipant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AnonymousParticipant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AnonymousParticipantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AnonymousParticipant.prisma().count()

        # results: prisma.types.AnonymousParticipantCountAggregateOutput
        results = await AnonymousParticipant.prisma().count(
            select={
                '_all': True,
                'lastName': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AnonymousParticipantCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AnonymousParticipantWhereInput] = None,
        cursor: Optional[types.AnonymousParticipantWhereUniqueInput] = None,
    ) -> types.AnonymousParticipantCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AnonymousParticipantCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AnonymousParticipantWhereInput] = None,
        cursor: Optional[types.AnonymousParticipantWhereUniqueInput] = None,
    ) -> Union[int, types.AnonymousParticipantCountAggregateOutput]:
        """Count the number of AnonymousParticipant records present in the database

        Parameters
        ----------
        select
            Select the AnonymousParticipant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AnonymousParticipant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AnonymousParticipantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AnonymousParticipant.prisma().count()

        # results: prisma.types.AnonymousParticipantCountAggregateOutput
        results = await AnonymousParticipant.prisma().count(
            select={
                '_all': True,
                'username': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AnonymousParticipantCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AnonymousParticipantWhereInput] = None
    ) -> int:
        """Delete multiple AnonymousParticipant records.

        Parameters
        ----------
        where
            Optional AnonymousParticipant filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AnonymousParticipant records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AnonymousParticipant records
        total = await AnonymousParticipant.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AnonymousParticipantScalarFieldKeys'],
        *,
        where: Optional['types.AnonymousParticipantWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AnonymousParticipantAvgAggregateInput'] = None,
        sum: Optional['types.AnonymousParticipantSumAggregateInput'] = None,
        min: Optional['types.AnonymousParticipantMinAggregateInput'] = None,
        max: Optional['types.AnonymousParticipantMaxAggregateInput'] = None,
        having: Optional['types.AnonymousParticipantScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AnonymousParticipantCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AnonymousParticipantScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AnonymousParticipantScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AnonymousParticipantGroupByOutput']:
        """Group AnonymousParticipant records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AnonymousParticipant fields to group records by
        where
            AnonymousParticipant filter to select records
        take
            Limit the maximum number of AnonymousParticipant records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AnonymousParticipantGroupByOutput]
            A list of dictionaries representing the AnonymousParticipant record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AnonymousParticipant records by email values
        # and count how many records are in each group
        results = await AnonymousParticipant.prisma().group_by(
            ['email'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MessageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.MessageCreateInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Create a new Message record.

        Parameters
        ----------
        data
            Message record data
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created Message record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Message record from just the required fields
        message = await Message.prisma().create(
            data={
                # data to create a Message record
                'conversationId': 'fcfhgbjed',
                'content': 'hdgcajhjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MessageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Message records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Message record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Message.prisma().create_many(
            data=[
                {
                    # data to create a Message record
                    'conversationId': 'ejdjahicb',
                    'content': 'gdjgigfgc',
                },
                {
                    # data to create a Message record
                    'conversationId': 'gfeaahdeh',
                    'content': 'bjafcgbffc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Message record.

        Parameters
        ----------
        where
            Message filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The deleted Message record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().delete(
            where={
                'id': 'hihegjif',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Message record.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique(
            where={
                'id': 'bdjidcidac',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Message record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique_or_raise(
            where={
                'id': 'ifgaaagff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Message records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N results
        where
            Message filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Message]
            The list of all Message records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Message records
        messages = await Message.prisma().find_many(take=10)

        # find the first 5 Message records ordered by the id field
        messages = await Message.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Message record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the conversationId field
        message = await Message.prisma().find_first(
            skip=1,
            order={
                'conversationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Message record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the senderId field
        message = await Message.prisma().find_first_or_raise(
            skip=1,
            order={
                'senderId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MessageUpdateInput,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Message record.

        Parameters
        ----------
        data
            Message record data specifying what to update
        where
            Message filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The updated Message record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        message = await Message.prisma().update(
            where={
                'id': 'befcddgjce',
            },
            data={
                # data to update the Message record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MessageWhereUniqueInput,
        data: types.MessageUpsertInput,
        include: Optional[types.MessageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Message filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created or updated Message record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().upsert(
            where={
                'id': 'bfhdbjjgfd',
            },
            data={
                'create': {
                    'id': 'bfhdbjjgfd',
                    'conversationId': 'gfeaahdeh',
                    'content': 'bjafcgbffc',
                },
                'update': {
                    'conversationId': 'gfeaahdeh',
                    'content': 'bjafcgbffc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MessageUpdateManyMutationInput,
        where: types.MessageWhereInput,
    ) -> int:
        """Update multiple Message records

        Parameters
        ----------
        data
            Message data to update the selected Message records to
        where
            Filter to select the Message records to update

        Returns
        -------
        int
            The total number of Message records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Message records
        total = await Message.prisma().update_many(
            data={
                'anonymousSenderId': 'cabdjadaji'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'content': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MessageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> types.MessageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MessageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> Union[int, types.MessageCountAggregateOutput]:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'originalLanguage': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MessageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MessageWhereInput] = None
    ) -> int:
        """Delete multiple Message records.

        Parameters
        ----------
        where
            Optional Message filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Message records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Message records
        total = await Message.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MessageScalarFieldKeys'],
        *,
        where: Optional['types.MessageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MessageAvgAggregateInput'] = None,
        sum: Optional['types.MessageSumAggregateInput'] = None,
        min: Optional['types.MessageMinAggregateInput'] = None,
        max: Optional['types.MessageMaxAggregateInput'] = None,
        having: Optional['types.MessageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MessageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MessageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MessageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MessageGroupByOutput']:
        """Group Message records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Message fields to group records by
        where
            Message filter to select records
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MessageGroupByOutput]
            A list of dictionaries representing the Message record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Message records by messageType values
        # and count how many records are in each group
        results = await Message.prisma().group_by(
            ['messageType'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MessageTranslationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.MessageTranslationCreateInput,
        include: Optional[types.MessageTranslationInclude] = None
    ) -> _PrismaModelT:
        """Create a new MessageTranslation record.

        Parameters
        ----------
        data
            MessageTranslation record data
        include
            Specifies which relations should be loaded on the returned MessageTranslation model

        Returns
        -------
        prisma.models.MessageTranslation
            The created MessageTranslation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a MessageTranslation record from just the required fields
        messagetranslation = await MessageTranslation.prisma().create(
            data={
                # data to create a MessageTranslation record
                'messageId': 'faajgfadf',
                'sourceLanguage': 'biaagcedjc',
                'targetLanguage': 'cahhaghecf',
                'translatedContent': 'bghcbbcidi',
                'translationModel': 'jcgghhgdj',
                'cacheKey': 'beehgcebbg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MessageTranslationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple MessageTranslation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of MessageTranslation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await MessageTranslation.prisma().create_many(
            data=[
                {
                    # data to create a MessageTranslation record
                    'messageId': 'bhdiaidiaf',
                    'sourceLanguage': 'deajegcfi',
                    'targetLanguage': 'gabahhhjf',
                    'translatedContent': 'cjagadcjg',
                    'translationModel': 'bifficggej',
                    'cacheKey': 'bgbbaajbic',
                },
                {
                    # data to create a MessageTranslation record
                    'messageId': 'eegghdhjb',
                    'sourceLanguage': 'daafgidjg',
                    'targetLanguage': 'gdcgcgagj',
                    'translatedContent': 'bhceabbgja',
                    'translationModel': 'ehabfhegh',
                    'cacheKey': 'bcajcajjbc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MessageTranslationWhereUniqueInput,
        include: Optional[types.MessageTranslationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single MessageTranslation record.

        Parameters
        ----------
        where
            MessageTranslation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned MessageTranslation model

        Returns
        -------
        prisma.models.MessageTranslation
            The deleted MessageTranslation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messagetranslation = await MessageTranslation.prisma().delete(
            where={
                'id': 'bfdgheeegf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MessageTranslationWhereUniqueInput,
        include: Optional[types.MessageTranslationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique MessageTranslation record.

        Parameters
        ----------
        where
            MessageTranslation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MessageTranslation model

        Returns
        -------
        prisma.models.MessageTranslation
            The found MessageTranslation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messagetranslation = await MessageTranslation.prisma().find_unique(
            where={
                'id': 'ececbijji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MessageTranslationWhereUniqueInput,
        include: Optional[types.MessageTranslationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique MessageTranslation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            MessageTranslation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MessageTranslation model

        Returns
        -------
        prisma.models.MessageTranslation
            The found MessageTranslation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messagetranslation = await MessageTranslation.prisma().find_unique_or_raise(
            where={
                'id': 'cbcfgdcdhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageTranslationWhereInput] = None,
        cursor: Optional[types.MessageTranslationWhereUniqueInput] = None,
        include: Optional[types.MessageTranslationInclude] = None,
        order: Optional[Union[types.MessageTranslationOrderByInput, List[types.MessageTranslationOrderByInput]]] = None,
        distinct: Optional[List[types.MessageTranslationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple MessageTranslation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of MessageTranslation records returned
        skip
            Ignore the first N results
        where
            MessageTranslation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MessageTranslation model
        order
            Order the returned MessageTranslation records by any field
        distinct
            Filter MessageTranslation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.MessageTranslation]
            The list of all MessageTranslation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 MessageTranslation records
        messagetranslations = await MessageTranslation.prisma().find_many(take=10)

        # find the first 5 MessageTranslation records ordered by the id field
        messagetranslations = await MessageTranslation.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageTranslationWhereInput] = None,
        cursor: Optional[types.MessageTranslationWhereUniqueInput] = None,
        include: Optional[types.MessageTranslationInclude] = None,
        order: Optional[Union[types.MessageTranslationOrderByInput, List[types.MessageTranslationOrderByInput]]] = None,
        distinct: Optional[List[types.MessageTranslationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single MessageTranslation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MessageTranslation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MessageTranslation model
        order
            Order the returned MessageTranslation records by any field
        distinct
            Filter MessageTranslation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MessageTranslation
            The first MessageTranslation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MessageTranslation record ordered by the messageId field
        messagetranslation = await MessageTranslation.prisma().find_first(
            skip=1,
            order={
                'messageId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageTranslationWhereInput] = None,
        cursor: Optional[types.MessageTranslationWhereUniqueInput] = None,
        include: Optional[types.MessageTranslationInclude] = None,
        order: Optional[Union[types.MessageTranslationOrderByInput, List[types.MessageTranslationOrderByInput]]] = None,
        distinct: Optional[List[types.MessageTranslationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single MessageTranslation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MessageTranslation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MessageTranslation model
        order
            Order the returned MessageTranslation records by any field
        distinct
            Filter MessageTranslation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MessageTranslation
            The first MessageTranslation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MessageTranslation record ordered by the sourceLanguage field
        messagetranslation = await MessageTranslation.prisma().find_first_or_raise(
            skip=1,
            order={
                'sourceLanguage': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MessageTranslationUpdateInput,
        where: types.MessageTranslationWhereUniqueInput,
        include: Optional[types.MessageTranslationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single MessageTranslation record.

        Parameters
        ----------
        data
            MessageTranslation record data specifying what to update
        where
            MessageTranslation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned MessageTranslation model

        Returns
        -------
        prisma.models.MessageTranslation
            The updated MessageTranslation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        messagetranslation = await MessageTranslation.prisma().update(
            where={
                'id': 'fdgjfbhia',
            },
            data={
                # data to update the MessageTranslation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MessageTranslationWhereUniqueInput,
        data: types.MessageTranslationUpsertInput,
        include: Optional[types.MessageTranslationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            MessageTranslation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned MessageTranslation model

        Returns
        -------
        prisma.models.MessageTranslation
            The created or updated MessageTranslation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messagetranslation = await MessageTranslation.prisma().upsert(
            where={
                'id': 'jcehcdchh',
            },
            data={
                'create': {
                    'id': 'jcehcdchh',
                    'messageId': 'eegghdhjb',
                    'sourceLanguage': 'daafgidjg',
                    'targetLanguage': 'gdcgcgagj',
                    'translatedContent': 'bhceabbgja',
                    'translationModel': 'ehabfhegh',
                    'cacheKey': 'bcajcajjbc',
                },
                'update': {
                    'messageId': 'eegghdhjb',
                    'sourceLanguage': 'daafgidjg',
                    'targetLanguage': 'gdcgcgagj',
                    'translatedContent': 'bhceabbgja',
                    'translationModel': 'ehabfhegh',
                    'cacheKey': 'bcajcajjbc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MessageTranslationUpdateManyMutationInput,
        where: types.MessageTranslationWhereInput,
    ) -> int:
        """Update multiple MessageTranslation records

        Parameters
        ----------
        data
            MessageTranslation data to update the selected MessageTranslation records to
        where
            Filter to select the MessageTranslation records to update

        Returns
        -------
        int
            The total number of MessageTranslation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all MessageTranslation records
        total = await MessageTranslation.prisma().update_many(
            data={
                'targetLanguage': 'bgcbjdhjcc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageTranslationWhereInput] = None,
        cursor: Optional[types.MessageTranslationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of MessageTranslation records present in the database

        Parameters
        ----------
        select
            Select the MessageTranslation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MessageTranslation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageTranslationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MessageTranslation.prisma().count()

        # results: prisma.types.MessageTranslationCountAggregateOutput
        results = await MessageTranslation.prisma().count(
            select={
                '_all': True,
                'translatedContent': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MessageTranslationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageTranslationWhereInput] = None,
        cursor: Optional[types.MessageTranslationWhereUniqueInput] = None,
    ) -> types.MessageTranslationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MessageTranslationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageTranslationWhereInput] = None,
        cursor: Optional[types.MessageTranslationWhereUniqueInput] = None,
    ) -> Union[int, types.MessageTranslationCountAggregateOutput]:
        """Count the number of MessageTranslation records present in the database

        Parameters
        ----------
        select
            Select the MessageTranslation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MessageTranslation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageTranslationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MessageTranslation.prisma().count()

        # results: prisma.types.MessageTranslationCountAggregateOutput
        results = await MessageTranslation.prisma().count(
            select={
                '_all': True,
                'translationModel': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MessageTranslationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MessageTranslationWhereInput] = None
    ) -> int:
        """Delete multiple MessageTranslation records.

        Parameters
        ----------
        where
            Optional MessageTranslation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of MessageTranslation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all MessageTranslation records
        total = await MessageTranslation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MessageTranslationScalarFieldKeys'],
        *,
        where: Optional['types.MessageTranslationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MessageTranslationAvgAggregateInput'] = None,
        sum: Optional['types.MessageTranslationSumAggregateInput'] = None,
        min: Optional['types.MessageTranslationMinAggregateInput'] = None,
        max: Optional['types.MessageTranslationMaxAggregateInput'] = None,
        having: Optional['types.MessageTranslationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MessageTranslationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MessageTranslationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MessageTranslationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MessageTranslationGroupByOutput']:
        """Group MessageTranslation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar MessageTranslation fields to group records by
        where
            MessageTranslation filter to select records
        take
            Limit the maximum number of MessageTranslation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MessageTranslationGroupByOutput]
            A list of dictionaries representing the MessageTranslation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group MessageTranslation records by cacheKey values
        # and count how many records are in each group
        results = await MessageTranslation.prisma().group_by(
            ['cacheKey'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MessageReadStatusActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.MessageReadStatusCreateInput,
        include: Optional[types.MessageReadStatusInclude] = None
    ) -> _PrismaModelT:
        """Create a new MessageReadStatus record.

        Parameters
        ----------
        data
            MessageReadStatus record data
        include
            Specifies which relations should be loaded on the returned MessageReadStatus model

        Returns
        -------
        prisma.models.MessageReadStatus
            The created MessageReadStatus record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a MessageReadStatus record from just the required fields
        messagereadstatus = await MessageReadStatus.prisma().create(
            data={
                # data to create a MessageReadStatus record
                'messageId': 'bieiidcabj',
                'userId': 'bjcbfcieaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MessageReadStatusCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple MessageReadStatus records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of MessageReadStatus record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await MessageReadStatus.prisma().create_many(
            data=[
                {
                    # data to create a MessageReadStatus record
                    'messageId': 'cbaaechiej',
                    'userId': 'iejbeaaeg',
                },
                {
                    # data to create a MessageReadStatus record
                    'messageId': 'jcibfcbhf',
                    'userId': 'chdadcaga',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MessageReadStatusWhereUniqueInput,
        include: Optional[types.MessageReadStatusInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single MessageReadStatus record.

        Parameters
        ----------
        where
            MessageReadStatus filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned MessageReadStatus model

        Returns
        -------
        prisma.models.MessageReadStatus
            The deleted MessageReadStatus record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messagereadstatus = await MessageReadStatus.prisma().delete(
            where={
                'id': 'jicieifbh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MessageReadStatusWhereUniqueInput,
        include: Optional[types.MessageReadStatusInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique MessageReadStatus record.

        Parameters
        ----------
        where
            MessageReadStatus filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MessageReadStatus model

        Returns
        -------
        prisma.models.MessageReadStatus
            The found MessageReadStatus record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messagereadstatus = await MessageReadStatus.prisma().find_unique(
            where={
                'id': 'fbahdheji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MessageReadStatusWhereUniqueInput,
        include: Optional[types.MessageReadStatusInclude] = None
    ) -> _PrismaModelT:
        """Find a unique MessageReadStatus record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            MessageReadStatus filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MessageReadStatus model

        Returns
        -------
        prisma.models.MessageReadStatus
            The found MessageReadStatus record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messagereadstatus = await MessageReadStatus.prisma().find_unique_or_raise(
            where={
                'id': 'cbbheiicgh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageReadStatusWhereInput] = None,
        cursor: Optional[types.MessageReadStatusWhereUniqueInput] = None,
        include: Optional[types.MessageReadStatusInclude] = None,
        order: Optional[Union[types.MessageReadStatusOrderByInput, List[types.MessageReadStatusOrderByInput]]] = None,
        distinct: Optional[List[types.MessageReadStatusScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple MessageReadStatus records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of MessageReadStatus records returned
        skip
            Ignore the first N results
        where
            MessageReadStatus filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MessageReadStatus model
        order
            Order the returned MessageReadStatus records by any field
        distinct
            Filter MessageReadStatus records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.MessageReadStatus]
            The list of all MessageReadStatus records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 MessageReadStatus records
        messagereadstatus = await MessageReadStatus.prisma().find_many(take=10)

        # find the first 5 MessageReadStatus records ordered by the id field
        messagereadstatus = await MessageReadStatus.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageReadStatusWhereInput] = None,
        cursor: Optional[types.MessageReadStatusWhereUniqueInput] = None,
        include: Optional[types.MessageReadStatusInclude] = None,
        order: Optional[Union[types.MessageReadStatusOrderByInput, List[types.MessageReadStatusOrderByInput]]] = None,
        distinct: Optional[List[types.MessageReadStatusScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single MessageReadStatus record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MessageReadStatus filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MessageReadStatus model
        order
            Order the returned MessageReadStatus records by any field
        distinct
            Filter MessageReadStatus records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MessageReadStatus
            The first MessageReadStatus record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MessageReadStatus record ordered by the messageId field
        messagereadstatus = await MessageReadStatus.prisma().find_first(
            skip=1,
            order={
                'messageId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageReadStatusWhereInput] = None,
        cursor: Optional[types.MessageReadStatusWhereUniqueInput] = None,
        include: Optional[types.MessageReadStatusInclude] = None,
        order: Optional[Union[types.MessageReadStatusOrderByInput, List[types.MessageReadStatusOrderByInput]]] = None,
        distinct: Optional[List[types.MessageReadStatusScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single MessageReadStatus record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MessageReadStatus filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MessageReadStatus model
        order
            Order the returned MessageReadStatus records by any field
        distinct
            Filter MessageReadStatus records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MessageReadStatus
            The first MessageReadStatus record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MessageReadStatus record ordered by the userId field
        messagereadstatus = await MessageReadStatus.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MessageReadStatusUpdateInput,
        where: types.MessageReadStatusWhereUniqueInput,
        include: Optional[types.MessageReadStatusInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single MessageReadStatus record.

        Parameters
        ----------
        data
            MessageReadStatus record data specifying what to update
        where
            MessageReadStatus filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned MessageReadStatus model

        Returns
        -------
        prisma.models.MessageReadStatus
            The updated MessageReadStatus record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        messagereadstatus = await MessageReadStatus.prisma().update(
            where={
                'id': 'beabjeejdg',
            },
            data={
                # data to update the MessageReadStatus record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MessageReadStatusWhereUniqueInput,
        data: types.MessageReadStatusUpsertInput,
        include: Optional[types.MessageReadStatusInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            MessageReadStatus filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned MessageReadStatus model

        Returns
        -------
        prisma.models.MessageReadStatus
            The created or updated MessageReadStatus record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messagereadstatus = await MessageReadStatus.prisma().upsert(
            where={
                'id': 'bcjhgahffd',
            },
            data={
                'create': {
                    'id': 'bcjhgahffd',
                    'messageId': 'jcibfcbhf',
                    'userId': 'chdadcaga',
                },
                'update': {
                    'messageId': 'jcibfcbhf',
                    'userId': 'chdadcaga',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MessageReadStatusUpdateManyMutationInput,
        where: types.MessageReadStatusWhereInput,
    ) -> int:
        """Update multiple MessageReadStatus records

        Parameters
        ----------
        data
            MessageReadStatus data to update the selected MessageReadStatus records to
        where
            Filter to select the MessageReadStatus records to update

        Returns
        -------
        int
            The total number of MessageReadStatus records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all MessageReadStatus records
        total = await MessageReadStatus.prisma().update_many(
            data={
                'readAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageReadStatusWhereInput] = None,
        cursor: Optional[types.MessageReadStatusWhereUniqueInput] = None,
    ) -> int:
        """Count the number of MessageReadStatus records present in the database

        Parameters
        ----------
        select
            Select the MessageReadStatus fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MessageReadStatus filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageReadStatusCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MessageReadStatus.prisma().count()

        # results: prisma.types.MessageReadStatusCountAggregateOutput
        results = await MessageReadStatus.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MessageReadStatusCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageReadStatusWhereInput] = None,
        cursor: Optional[types.MessageReadStatusWhereUniqueInput] = None,
    ) -> types.MessageReadStatusCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MessageReadStatusCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageReadStatusWhereInput] = None,
        cursor: Optional[types.MessageReadStatusWhereUniqueInput] = None,
    ) -> Union[int, types.MessageReadStatusCountAggregateOutput]:
        """Count the number of MessageReadStatus records present in the database

        Parameters
        ----------
        select
            Select the MessageReadStatus fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MessageReadStatus filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageReadStatusCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MessageReadStatus.prisma().count()

        # results: prisma.types.MessageReadStatusCountAggregateOutput
        results = await MessageReadStatus.prisma().count(
            select={
                '_all': True,
                'messageId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MessageReadStatusCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MessageReadStatusWhereInput] = None
    ) -> int:
        """Delete multiple MessageReadStatus records.

        Parameters
        ----------
        where
            Optional MessageReadStatus filter to find the records to be deleted

        Returns
        -------
        int
            The total number of MessageReadStatus records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all MessageReadStatus records
        total = await MessageReadStatus.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MessageReadStatusScalarFieldKeys'],
        *,
        where: Optional['types.MessageReadStatusWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MessageReadStatusAvgAggregateInput'] = None,
        sum: Optional['types.MessageReadStatusSumAggregateInput'] = None,
        min: Optional['types.MessageReadStatusMinAggregateInput'] = None,
        max: Optional['types.MessageReadStatusMaxAggregateInput'] = None,
        having: Optional['types.MessageReadStatusScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MessageReadStatusCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MessageReadStatusScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MessageReadStatusScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MessageReadStatusGroupByOutput']:
        """Group MessageReadStatus records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar MessageReadStatus fields to group records by
        where
            MessageReadStatus filter to select records
        take
            Limit the maximum number of MessageReadStatus records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MessageReadStatusGroupByOutput]
            A list of dictionaries representing the MessageReadStatus record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group MessageReadStatus records by userId values
        # and count how many records are in each group
        results = await MessageReadStatus.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FriendRequestActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.FriendRequestCreateInput,
        include: Optional[types.FriendRequestInclude] = None
    ) -> _PrismaModelT:
        """Create a new FriendRequest record.

        Parameters
        ----------
        data
            FriendRequest record data
        include
            Specifies which relations should be loaded on the returned FriendRequest model

        Returns
        -------
        prisma.models.FriendRequest
            The created FriendRequest record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a FriendRequest record from just the required fields
        friendrequest = await FriendRequest.prisma().create(
            data={
                # data to create a FriendRequest record
                'senderId': 'fbjeiiffa',
                'receiverId': 'jhgidcgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FriendRequestCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple FriendRequest records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of FriendRequest record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await FriendRequest.prisma().create_many(
            data=[
                {
                    # data to create a FriendRequest record
                    'senderId': 'bgjgecfejc',
                    'receiverId': 'bgjcgchib',
                },
                {
                    # data to create a FriendRequest record
                    'senderId': 'bacdaibgfa',
                    'receiverId': 'dchgibach',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FriendRequestWhereUniqueInput,
        include: Optional[types.FriendRequestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single FriendRequest record.

        Parameters
        ----------
        where
            FriendRequest filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned FriendRequest model

        Returns
        -------
        prisma.models.FriendRequest
            The deleted FriendRequest record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        friendrequest = await FriendRequest.prisma().delete(
            where={
                'id': 'fchheijjc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FriendRequestWhereUniqueInput,
        include: Optional[types.FriendRequestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique FriendRequest record.

        Parameters
        ----------
        where
            FriendRequest filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FriendRequest model

        Returns
        -------
        prisma.models.FriendRequest
            The found FriendRequest record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        friendrequest = await FriendRequest.prisma().find_unique(
            where={
                'id': 'cacjdfhejh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FriendRequestWhereUniqueInput,
        include: Optional[types.FriendRequestInclude] = None
    ) -> _PrismaModelT:
        """Find a unique FriendRequest record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            FriendRequest filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FriendRequest model

        Returns
        -------
        prisma.models.FriendRequest
            The found FriendRequest record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        friendrequest = await FriendRequest.prisma().find_unique_or_raise(
            where={
                'id': 'bdbifjhbbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FriendRequestWhereInput] = None,
        cursor: Optional[types.FriendRequestWhereUniqueInput] = None,
        include: Optional[types.FriendRequestInclude] = None,
        order: Optional[Union[types.FriendRequestOrderByInput, List[types.FriendRequestOrderByInput]]] = None,
        distinct: Optional[List[types.FriendRequestScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple FriendRequest records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of FriendRequest records returned
        skip
            Ignore the first N results
        where
            FriendRequest filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FriendRequest model
        order
            Order the returned FriendRequest records by any field
        distinct
            Filter FriendRequest records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.FriendRequest]
            The list of all FriendRequest records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 FriendRequest records
        friendrequests = await FriendRequest.prisma().find_many(take=10)

        # find the first 5 FriendRequest records ordered by the id field
        friendrequests = await FriendRequest.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FriendRequestWhereInput] = None,
        cursor: Optional[types.FriendRequestWhereUniqueInput] = None,
        include: Optional[types.FriendRequestInclude] = None,
        order: Optional[Union[types.FriendRequestOrderByInput, List[types.FriendRequestOrderByInput]]] = None,
        distinct: Optional[List[types.FriendRequestScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single FriendRequest record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FriendRequest filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FriendRequest model
        order
            Order the returned FriendRequest records by any field
        distinct
            Filter FriendRequest records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FriendRequest
            The first FriendRequest record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FriendRequest record ordered by the senderId field
        friendrequest = await FriendRequest.prisma().find_first(
            skip=1,
            order={
                'senderId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FriendRequestWhereInput] = None,
        cursor: Optional[types.FriendRequestWhereUniqueInput] = None,
        include: Optional[types.FriendRequestInclude] = None,
        order: Optional[Union[types.FriendRequestOrderByInput, List[types.FriendRequestOrderByInput]]] = None,
        distinct: Optional[List[types.FriendRequestScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single FriendRequest record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FriendRequest filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FriendRequest model
        order
            Order the returned FriendRequest records by any field
        distinct
            Filter FriendRequest records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FriendRequest
            The first FriendRequest record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FriendRequest record ordered by the receiverId field
        friendrequest = await FriendRequest.prisma().find_first_or_raise(
            skip=1,
            order={
                'receiverId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FriendRequestUpdateInput,
        where: types.FriendRequestWhereUniqueInput,
        include: Optional[types.FriendRequestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single FriendRequest record.

        Parameters
        ----------
        data
            FriendRequest record data specifying what to update
        where
            FriendRequest filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned FriendRequest model

        Returns
        -------
        prisma.models.FriendRequest
            The updated FriendRequest record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        friendrequest = await FriendRequest.prisma().update(
            where={
                'id': 'cbccbbcdfb',
            },
            data={
                # data to update the FriendRequest record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FriendRequestWhereUniqueInput,
        data: types.FriendRequestUpsertInput,
        include: Optional[types.FriendRequestInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            FriendRequest filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned FriendRequest model

        Returns
        -------
        prisma.models.FriendRequest
            The created or updated FriendRequest record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        friendrequest = await FriendRequest.prisma().upsert(
            where={
                'id': 'bacejedaca',
            },
            data={
                'create': {
                    'id': 'bacejedaca',
                    'senderId': 'bacdaibgfa',
                    'receiverId': 'dchgibach',
                },
                'update': {
                    'senderId': 'bacdaibgfa',
                    'receiverId': 'dchgibach',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FriendRequestUpdateManyMutationInput,
        where: types.FriendRequestWhereInput,
    ) -> int:
        """Update multiple FriendRequest records

        Parameters
        ----------
        data
            FriendRequest data to update the selected FriendRequest records to
        where
            Filter to select the FriendRequest records to update

        Returns
        -------
        int
            The total number of FriendRequest records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all FriendRequest records
        total = await FriendRequest.prisma().update_many(
            data={
                'status': 'bhbhdahfaj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FriendRequestWhereInput] = None,
        cursor: Optional[types.FriendRequestWhereUniqueInput] = None,
    ) -> int:
        """Count the number of FriendRequest records present in the database

        Parameters
        ----------
        select
            Select the FriendRequest fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FriendRequest filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FriendRequestCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await FriendRequest.prisma().count()

        # results: prisma.types.FriendRequestCountAggregateOutput
        results = await FriendRequest.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FriendRequestCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FriendRequestWhereInput] = None,
        cursor: Optional[types.FriendRequestWhereUniqueInput] = None,
    ) -> types.FriendRequestCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FriendRequestCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FriendRequestWhereInput] = None,
        cursor: Optional[types.FriendRequestWhereUniqueInput] = None,
    ) -> Union[int, types.FriendRequestCountAggregateOutput]:
        """Count the number of FriendRequest records present in the database

        Parameters
        ----------
        select
            Select the FriendRequest fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FriendRequest filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FriendRequestCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await FriendRequest.prisma().count()

        # results: prisma.types.FriendRequestCountAggregateOutput
        results = await FriendRequest.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FriendRequestCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FriendRequestWhereInput] = None
    ) -> int:
        """Delete multiple FriendRequest records.

        Parameters
        ----------
        where
            Optional FriendRequest filter to find the records to be deleted

        Returns
        -------
        int
            The total number of FriendRequest records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all FriendRequest records
        total = await FriendRequest.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FriendRequestScalarFieldKeys'],
        *,
        where: Optional['types.FriendRequestWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FriendRequestAvgAggregateInput'] = None,
        sum: Optional['types.FriendRequestSumAggregateInput'] = None,
        min: Optional['types.FriendRequestMinAggregateInput'] = None,
        max: Optional['types.FriendRequestMaxAggregateInput'] = None,
        having: Optional['types.FriendRequestScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FriendRequestCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FriendRequestScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.FriendRequestScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.FriendRequestGroupByOutput']:
        """Group FriendRequest records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar FriendRequest fields to group records by
        where
            FriendRequest filter to select records
        take
            Limit the maximum number of FriendRequest records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FriendRequestGroupByOutput]
            A list of dictionaries representing the FriendRequest record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group FriendRequest records by id values
        # and count how many records are in each group
        results = await FriendRequest.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TypingIndicatorActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.TypingIndicatorCreateInput,
        include: Optional[types.TypingIndicatorInclude] = None
    ) -> _PrismaModelT:
        """Create a new TypingIndicator record.

        Parameters
        ----------
        data
            TypingIndicator record data
        include
            Specifies which relations should be loaded on the returned TypingIndicator model

        Returns
        -------
        prisma.models.TypingIndicator
            The created TypingIndicator record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TypingIndicator record from just the required fields
        typingindicator = await TypingIndicator.prisma().create(
            data={
                # data to create a TypingIndicator record
                'conversationId': 'bfjibceaec',
                'userId': 'ibhgcdbgd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TypingIndicatorCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TypingIndicator records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TypingIndicator record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TypingIndicator.prisma().create_many(
            data=[
                {
                    # data to create a TypingIndicator record
                    'conversationId': 'badaffhddg',
                    'userId': 'bbdbfcfihd',
                },
                {
                    # data to create a TypingIndicator record
                    'conversationId': 'cbagggbji',
                    'userId': 'bchgafhjed',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TypingIndicatorWhereUniqueInput,
        include: Optional[types.TypingIndicatorInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TypingIndicator record.

        Parameters
        ----------
        where
            TypingIndicator filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TypingIndicator model

        Returns
        -------
        prisma.models.TypingIndicator
            The deleted TypingIndicator record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        typingindicator = await TypingIndicator.prisma().delete(
            where={
                'id': 'heffgjdei',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TypingIndicatorWhereUniqueInput,
        include: Optional[types.TypingIndicatorInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TypingIndicator record.

        Parameters
        ----------
        where
            TypingIndicator filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TypingIndicator model

        Returns
        -------
        prisma.models.TypingIndicator
            The found TypingIndicator record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        typingindicator = await TypingIndicator.prisma().find_unique(
            where={
                'id': 'dahihgbeb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TypingIndicatorWhereUniqueInput,
        include: Optional[types.TypingIndicatorInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TypingIndicator record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TypingIndicator filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TypingIndicator model

        Returns
        -------
        prisma.models.TypingIndicator
            The found TypingIndicator record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        typingindicator = await TypingIndicator.prisma().find_unique_or_raise(
            where={
                'id': 'bgheaejbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TypingIndicatorWhereInput] = None,
        cursor: Optional[types.TypingIndicatorWhereUniqueInput] = None,
        include: Optional[types.TypingIndicatorInclude] = None,
        order: Optional[Union[types.TypingIndicatorOrderByInput, List[types.TypingIndicatorOrderByInput]]] = None,
        distinct: Optional[List[types.TypingIndicatorScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TypingIndicator records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TypingIndicator records returned
        skip
            Ignore the first N results
        where
            TypingIndicator filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TypingIndicator model
        order
            Order the returned TypingIndicator records by any field
        distinct
            Filter TypingIndicator records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TypingIndicator]
            The list of all TypingIndicator records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TypingIndicator records
        typingindicators = await TypingIndicator.prisma().find_many(take=10)

        # find the first 5 TypingIndicator records ordered by the id field
        typingindicators = await TypingIndicator.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TypingIndicatorWhereInput] = None,
        cursor: Optional[types.TypingIndicatorWhereUniqueInput] = None,
        include: Optional[types.TypingIndicatorInclude] = None,
        order: Optional[Union[types.TypingIndicatorOrderByInput, List[types.TypingIndicatorOrderByInput]]] = None,
        distinct: Optional[List[types.TypingIndicatorScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TypingIndicator record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TypingIndicator filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TypingIndicator model
        order
            Order the returned TypingIndicator records by any field
        distinct
            Filter TypingIndicator records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TypingIndicator
            The first TypingIndicator record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TypingIndicator record ordered by the conversationId field
        typingindicator = await TypingIndicator.prisma().find_first(
            skip=1,
            order={
                'conversationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TypingIndicatorWhereInput] = None,
        cursor: Optional[types.TypingIndicatorWhereUniqueInput] = None,
        include: Optional[types.TypingIndicatorInclude] = None,
        order: Optional[Union[types.TypingIndicatorOrderByInput, List[types.TypingIndicatorOrderByInput]]] = None,
        distinct: Optional[List[types.TypingIndicatorScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TypingIndicator record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TypingIndicator filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TypingIndicator model
        order
            Order the returned TypingIndicator records by any field
        distinct
            Filter TypingIndicator records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TypingIndicator
            The first TypingIndicator record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TypingIndicator record ordered by the userId field
        typingindicator = await TypingIndicator.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TypingIndicatorUpdateInput,
        where: types.TypingIndicatorWhereUniqueInput,
        include: Optional[types.TypingIndicatorInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TypingIndicator record.

        Parameters
        ----------
        data
            TypingIndicator record data specifying what to update
        where
            TypingIndicator filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TypingIndicator model

        Returns
        -------
        prisma.models.TypingIndicator
            The updated TypingIndicator record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        typingindicator = await TypingIndicator.prisma().update(
            where={
                'id': 'bfcgifeged',
            },
            data={
                # data to update the TypingIndicator record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TypingIndicatorWhereUniqueInput,
        data: types.TypingIndicatorUpsertInput,
        include: Optional[types.TypingIndicatorInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TypingIndicator filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TypingIndicator model

        Returns
        -------
        prisma.models.TypingIndicator
            The created or updated TypingIndicator record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        typingindicator = await TypingIndicator.prisma().upsert(
            where={
                'id': 'jfiahhbae',
            },
            data={
                'create': {
                    'id': 'jfiahhbae',
                    'conversationId': 'cbagggbji',
                    'userId': 'bchgafhjed',
                },
                'update': {
                    'conversationId': 'cbagggbji',
                    'userId': 'bchgafhjed',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TypingIndicatorUpdateManyMutationInput,
        where: types.TypingIndicatorWhereInput,
    ) -> int:
        """Update multiple TypingIndicator records

        Parameters
        ----------
        data
            TypingIndicator data to update the selected TypingIndicator records to
        where
            Filter to select the TypingIndicator records to update

        Returns
        -------
        int
            The total number of TypingIndicator records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TypingIndicator records
        total = await TypingIndicator.prisma().update_many(
            data={
                'isTyping': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TypingIndicatorWhereInput] = None,
        cursor: Optional[types.TypingIndicatorWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TypingIndicator records present in the database

        Parameters
        ----------
        select
            Select the TypingIndicator fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TypingIndicator filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TypingIndicatorCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TypingIndicator.prisma().count()

        # results: prisma.types.TypingIndicatorCountAggregateOutput
        results = await TypingIndicator.prisma().count(
            select={
                '_all': True,
                'startedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TypingIndicatorCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TypingIndicatorWhereInput] = None,
        cursor: Optional[types.TypingIndicatorWhereUniqueInput] = None,
    ) -> types.TypingIndicatorCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TypingIndicatorCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TypingIndicatorWhereInput] = None,
        cursor: Optional[types.TypingIndicatorWhereUniqueInput] = None,
    ) -> Union[int, types.TypingIndicatorCountAggregateOutput]:
        """Count the number of TypingIndicator records present in the database

        Parameters
        ----------
        select
            Select the TypingIndicator fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TypingIndicator filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TypingIndicatorCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TypingIndicator.prisma().count()

        # results: prisma.types.TypingIndicatorCountAggregateOutput
        results = await TypingIndicator.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TypingIndicatorCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TypingIndicatorWhereInput] = None
    ) -> int:
        """Delete multiple TypingIndicator records.

        Parameters
        ----------
        where
            Optional TypingIndicator filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TypingIndicator records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TypingIndicator records
        total = await TypingIndicator.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TypingIndicatorScalarFieldKeys'],
        *,
        where: Optional['types.TypingIndicatorWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TypingIndicatorAvgAggregateInput'] = None,
        sum: Optional['types.TypingIndicatorSumAggregateInput'] = None,
        min: Optional['types.TypingIndicatorMinAggregateInput'] = None,
        max: Optional['types.TypingIndicatorMaxAggregateInput'] = None,
        having: Optional['types.TypingIndicatorScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TypingIndicatorCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TypingIndicatorScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TypingIndicatorScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TypingIndicatorGroupByOutput']:
        """Group TypingIndicator records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TypingIndicator fields to group records by
        where
            TypingIndicator filter to select records
        take
            Limit the maximum number of TypingIndicator records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TypingIndicatorGroupByOutput]
            A list of dictionaries representing the TypingIndicator record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TypingIndicator records by id values
        # and count how many records are in each group
        results = await TypingIndicator.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NotificationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.NotificationCreateInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Notification record.

        Parameters
        ----------
        data
            Notification record data
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created Notification record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Notification record from just the required fields
        notification = await Notification.prisma().create(
            data={
                # data to create a Notification record
                'userId': 'caeghehde',
                'type': 'caghgfbggd',
                'title': 'bbidjbbjaa',
                'content': 'bfijhaejdd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NotificationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Notification records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Notification record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Notification.prisma().create_many(
            data=[
                {
                    # data to create a Notification record
                    'userId': 'bcedehfiji',
                    'type': 'bdgjicijhb',
                    'title': 'bghifjdeia',
                    'content': 'eadfcbbcb',
                },
                {
                    # data to create a Notification record
                    'userId': 'geihgahba',
                    'type': 'gahdcdhbj',
                    'title': 'begiijahea',
                    'content': 'gcjadjaaf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Notification record.

        Parameters
        ----------
        where
            Notification filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The deleted Notification record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().delete(
            where={
                'id': 'bcbebgiaic',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Notification record.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique(
            where={
                'id': 'ijigbdcbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Notification record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique_or_raise(
            where={
                'id': 'gfidhicai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Notification records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N results
        where
            Notification filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Notification]
            The list of all Notification records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Notification records
        notifications = await Notification.prisma().find_many(take=10)

        # find the first 5 Notification records ordered by the id field
        notifications = await Notification.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Notification record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the userId field
        notification = await Notification.prisma().find_first(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Notification record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the type field
        notification = await Notification.prisma().find_first_or_raise(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.NotificationUpdateInput,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Notification record.

        Parameters
        ----------
        data
            Notification record data specifying what to update
        where
            Notification filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The updated Notification record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        notification = await Notification.prisma().update(
            where={
                'id': 'jfegcaafh',
            },
            data={
                # data to update the Notification record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.NotificationWhereUniqueInput,
        data: types.NotificationUpsertInput,
        include: Optional[types.NotificationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Notification filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created or updated Notification record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().upsert(
            where={
                'id': 'bcbeiajjfa',
            },
            data={
                'create': {
                    'id': 'bcbeiajjfa',
                    'userId': 'geihgahba',
                    'type': 'gahdcdhbj',
                    'title': 'begiijahea',
                    'content': 'gcjadjaaf',
                },
                'update': {
                    'userId': 'geihgahba',
                    'type': 'gahdcdhbj',
                    'title': 'begiijahea',
                    'content': 'gcjadjaaf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.NotificationUpdateManyMutationInput,
        where: types.NotificationWhereInput,
    ) -> int:
        """Update multiple Notification records

        Parameters
        ----------
        data
            Notification data to update the selected Notification records to
        where
            Filter to select the Notification records to update

        Returns
        -------
        int
            The total number of Notification records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Notification records
        total = await Notification.prisma().update_many(
            data={
                'title': 'baehicaajf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'content': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NotificationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> types.NotificationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NotificationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> Union[int, types.NotificationCountAggregateOutput]:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'data': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NotificationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NotificationWhereInput] = None
    ) -> int:
        """Delete multiple Notification records.

        Parameters
        ----------
        where
            Optional Notification filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Notification records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Notification records
        total = await Notification.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NotificationScalarFieldKeys'],
        *,
        where: Optional['types.NotificationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NotificationAvgAggregateInput'] = None,
        sum: Optional['types.NotificationSumAggregateInput'] = None,
        min: Optional['types.NotificationMinAggregateInput'] = None,
        max: Optional['types.NotificationMaxAggregateInput'] = None,
        having: Optional['types.NotificationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NotificationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NotificationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.NotificationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.NotificationGroupByOutput']:
        """Group Notification records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Notification fields to group records by
        where
            Notification filter to select records
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NotificationGroupByOutput]
            A list of dictionaries representing the Notification record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Notification records by priority values
        # and count how many records are in each group
        results = await Notification.prisma().group_by(
            ['priority'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CommunityActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.CommunityCreateInput,
        include: Optional[types.CommunityInclude] = None
    ) -> _PrismaModelT:
        """Create a new Community record.

        Parameters
        ----------
        data
            Community record data
        include
            Specifies which relations should be loaded on the returned Community model

        Returns
        -------
        prisma.models.Community
            The created Community record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Community record from just the required fields
        community = await Community.prisma().create(
            data={
                # data to create a Community record
                'name': 'bdachdeiga',
                'createdBy': 'ijdafccef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CommunityCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Community records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Community record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Community.prisma().create_many(
            data=[
                {
                    # data to create a Community record
                    'name': 'ciaaiddag',
                    'createdBy': 'fejggijff',
                },
                {
                    # data to create a Community record
                    'name': 'hghjaaai',
                    'createdBy': 'cajicjjdef',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CommunityWhereUniqueInput,
        include: Optional[types.CommunityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Community record.

        Parameters
        ----------
        where
            Community filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Community model

        Returns
        -------
        prisma.models.Community
            The deleted Community record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        community = await Community.prisma().delete(
            where={
                'id': 'cefjaadec',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CommunityWhereUniqueInput,
        include: Optional[types.CommunityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Community record.

        Parameters
        ----------
        where
            Community filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Community model

        Returns
        -------
        prisma.models.Community
            The found Community record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        community = await Community.prisma().find_unique(
            where={
                'id': 'ibbigdigd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CommunityWhereUniqueInput,
        include: Optional[types.CommunityInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Community record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Community filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Community model

        Returns
        -------
        prisma.models.Community
            The found Community record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        community = await Community.prisma().find_unique_or_raise(
            where={
                'id': 'bdiiiabbii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityWhereInput] = None,
        cursor: Optional[types.CommunityWhereUniqueInput] = None,
        include: Optional[types.CommunityInclude] = None,
        order: Optional[Union[types.CommunityOrderByInput, List[types.CommunityOrderByInput]]] = None,
        distinct: Optional[List[types.CommunityScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Community records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Community records returned
        skip
            Ignore the first N results
        where
            Community filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Community model
        order
            Order the returned Community records by any field
        distinct
            Filter Community records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Community]
            The list of all Community records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Community records
        communitys = await Community.prisma().find_many(take=10)

        # find the first 5 Community records ordered by the id field
        communitys = await Community.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommunityWhereInput] = None,
        cursor: Optional[types.CommunityWhereUniqueInput] = None,
        include: Optional[types.CommunityInclude] = None,
        order: Optional[Union[types.CommunityOrderByInput, List[types.CommunityOrderByInput]]] = None,
        distinct: Optional[List[types.CommunityScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Community record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Community filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Community model
        order
            Order the returned Community records by any field
        distinct
            Filter Community records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Community
            The first Community record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Community record ordered by the name field
        community = await Community.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommunityWhereInput] = None,
        cursor: Optional[types.CommunityWhereUniqueInput] = None,
        include: Optional[types.CommunityInclude] = None,
        order: Optional[Union[types.CommunityOrderByInput, List[types.CommunityOrderByInput]]] = None,
        distinct: Optional[List[types.CommunityScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Community record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Community filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Community model
        order
            Order the returned Community records by any field
        distinct
            Filter Community records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Community
            The first Community record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Community record ordered by the description field
        community = await Community.prisma().find_first_or_raise(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CommunityUpdateInput,
        where: types.CommunityWhereUniqueInput,
        include: Optional[types.CommunityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Community record.

        Parameters
        ----------
        data
            Community record data specifying what to update
        where
            Community filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Community model

        Returns
        -------
        prisma.models.Community
            The updated Community record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        community = await Community.prisma().update(
            where={
                'id': 'hfcfhhadh',
            },
            data={
                # data to update the Community record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CommunityWhereUniqueInput,
        data: types.CommunityUpsertInput,
        include: Optional[types.CommunityInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Community filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Community model

        Returns
        -------
        prisma.models.Community
            The created or updated Community record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        community = await Community.prisma().upsert(
            where={
                'id': 'bbihggdcji',
            },
            data={
                'create': {
                    'id': 'bbihggdcji',
                    'name': 'hghjaaai',
                    'createdBy': 'cajicjjdef',
                },
                'update': {
                    'name': 'hghjaaai',
                    'createdBy': 'cajicjjdef',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CommunityUpdateManyMutationInput,
        where: types.CommunityWhereInput,
    ) -> int:
        """Update multiple Community records

        Parameters
        ----------
        data
            Community data to update the selected Community records to
        where
            Filter to select the Community records to update

        Returns
        -------
        int
            The total number of Community records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Community records
        total = await Community.prisma().update_many(
            data={
                'avatar': 'hgjgibdgd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityWhereInput] = None,
        cursor: Optional[types.CommunityWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Community records present in the database

        Parameters
        ----------
        select
            Select the Community fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Community filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommunityCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Community.prisma().count()

        # results: prisma.types.CommunityCountAggregateOutput
        results = await Community.prisma().count(
            select={
                '_all': True,
                'isPrivate': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CommunityCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityWhereInput] = None,
        cursor: Optional[types.CommunityWhereUniqueInput] = None,
    ) -> types.CommunityCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CommunityCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityWhereInput] = None,
        cursor: Optional[types.CommunityWhereUniqueInput] = None,
    ) -> Union[int, types.CommunityCountAggregateOutput]:
        """Count the number of Community records present in the database

        Parameters
        ----------
        select
            Select the Community fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Community filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommunityCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Community.prisma().count()

        # results: prisma.types.CommunityCountAggregateOutput
        results = await Community.prisma().count(
            select={
                '_all': True,
                'createdBy': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CommunityCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CommunityWhereInput] = None
    ) -> int:
        """Delete multiple Community records.

        Parameters
        ----------
        where
            Optional Community filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Community records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Community records
        total = await Community.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CommunityScalarFieldKeys'],
        *,
        where: Optional['types.CommunityWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CommunityAvgAggregateInput'] = None,
        sum: Optional['types.CommunitySumAggregateInput'] = None,
        min: Optional['types.CommunityMinAggregateInput'] = None,
        max: Optional['types.CommunityMaxAggregateInput'] = None,
        having: Optional['types.CommunityScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CommunityCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CommunityScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CommunityScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CommunityGroupByOutput']:
        """Group Community records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Community fields to group records by
        where
            Community filter to select records
        take
            Limit the maximum number of Community records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CommunityGroupByOutput]
            A list of dictionaries representing the Community record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Community records by createdAt values
        # and count how many records are in each group
        results = await Community.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CommunityMemberActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.CommunityMemberCreateInput,
        include: Optional[types.CommunityMemberInclude] = None
    ) -> _PrismaModelT:
        """Create a new CommunityMember record.

        Parameters
        ----------
        data
            CommunityMember record data
        include
            Specifies which relations should be loaded on the returned CommunityMember model

        Returns
        -------
        prisma.models.CommunityMember
            The created CommunityMember record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CommunityMember record from just the required fields
        communitymember = await CommunityMember.prisma().create(
            data={
                # data to create a CommunityMember record
                'communityId': 'bcbecjfice',
                'userId': 'bacbebhjjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CommunityMemberCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CommunityMember records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CommunityMember record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CommunityMember.prisma().create_many(
            data=[
                {
                    # data to create a CommunityMember record
                    'communityId': 'dfbfaddhe',
                    'userId': 'bdcbbieibf',
                },
                {
                    # data to create a CommunityMember record
                    'communityId': 'dgjhdcggi',
                    'userId': 'bbjbcdfabd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CommunityMemberWhereUniqueInput,
        include: Optional[types.CommunityMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CommunityMember record.

        Parameters
        ----------
        where
            CommunityMember filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CommunityMember model

        Returns
        -------
        prisma.models.CommunityMember
            The deleted CommunityMember record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        communitymember = await CommunityMember.prisma().delete(
            where={
                'id': 'gchfgbcec',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CommunityMemberWhereUniqueInput,
        include: Optional[types.CommunityMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CommunityMember record.

        Parameters
        ----------
        where
            CommunityMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CommunityMember model

        Returns
        -------
        prisma.models.CommunityMember
            The found CommunityMember record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        communitymember = await CommunityMember.prisma().find_unique(
            where={
                'id': 'bihcjfcjah',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CommunityMemberWhereUniqueInput,
        include: Optional[types.CommunityMemberInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CommunityMember record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CommunityMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CommunityMember model

        Returns
        -------
        prisma.models.CommunityMember
            The found CommunityMember record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        communitymember = await CommunityMember.prisma().find_unique_or_raise(
            where={
                'id': 'bhjdcicaii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityMemberWhereInput] = None,
        cursor: Optional[types.CommunityMemberWhereUniqueInput] = None,
        include: Optional[types.CommunityMemberInclude] = None,
        order: Optional[Union[types.CommunityMemberOrderByInput, List[types.CommunityMemberOrderByInput]]] = None,
        distinct: Optional[List[types.CommunityMemberScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CommunityMember records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CommunityMember records returned
        skip
            Ignore the first N results
        where
            CommunityMember filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommunityMember model
        order
            Order the returned CommunityMember records by any field
        distinct
            Filter CommunityMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CommunityMember]
            The list of all CommunityMember records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CommunityMember records
        communitymembers = await CommunityMember.prisma().find_many(take=10)

        # find the first 5 CommunityMember records ordered by the id field
        communitymembers = await CommunityMember.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommunityMemberWhereInput] = None,
        cursor: Optional[types.CommunityMemberWhereUniqueInput] = None,
        include: Optional[types.CommunityMemberInclude] = None,
        order: Optional[Union[types.CommunityMemberOrderByInput, List[types.CommunityMemberOrderByInput]]] = None,
        distinct: Optional[List[types.CommunityMemberScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CommunityMember record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CommunityMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommunityMember model
        order
            Order the returned CommunityMember records by any field
        distinct
            Filter CommunityMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CommunityMember
            The first CommunityMember record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CommunityMember record ordered by the communityId field
        communitymember = await CommunityMember.prisma().find_first(
            skip=1,
            order={
                'communityId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommunityMemberWhereInput] = None,
        cursor: Optional[types.CommunityMemberWhereUniqueInput] = None,
        include: Optional[types.CommunityMemberInclude] = None,
        order: Optional[Union[types.CommunityMemberOrderByInput, List[types.CommunityMemberOrderByInput]]] = None,
        distinct: Optional[List[types.CommunityMemberScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CommunityMember record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CommunityMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommunityMember model
        order
            Order the returned CommunityMember records by any field
        distinct
            Filter CommunityMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CommunityMember
            The first CommunityMember record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CommunityMember record ordered by the userId field
        communitymember = await CommunityMember.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CommunityMemberUpdateInput,
        where: types.CommunityMemberWhereUniqueInput,
        include: Optional[types.CommunityMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CommunityMember record.

        Parameters
        ----------
        data
            CommunityMember record data specifying what to update
        where
            CommunityMember filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CommunityMember model

        Returns
        -------
        prisma.models.CommunityMember
            The updated CommunityMember record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        communitymember = await CommunityMember.prisma().update(
            where={
                'id': 'bibedjhcej',
            },
            data={
                # data to update the CommunityMember record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CommunityMemberWhereUniqueInput,
        data: types.CommunityMemberUpsertInput,
        include: Optional[types.CommunityMemberInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CommunityMember filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CommunityMember model

        Returns
        -------
        prisma.models.CommunityMember
            The created or updated CommunityMember record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        communitymember = await CommunityMember.prisma().upsert(
            where={
                'id': 'bjcdajabfa',
            },
            data={
                'create': {
                    'id': 'bjcdajabfa',
                    'communityId': 'dgjhdcggi',
                    'userId': 'bbjbcdfabd',
                },
                'update': {
                    'communityId': 'dgjhdcggi',
                    'userId': 'bbjbcdfabd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CommunityMemberUpdateManyMutationInput,
        where: types.CommunityMemberWhereInput,
    ) -> int:
        """Update multiple CommunityMember records

        Parameters
        ----------
        data
            CommunityMember data to update the selected CommunityMember records to
        where
            Filter to select the CommunityMember records to update

        Returns
        -------
        int
            The total number of CommunityMember records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CommunityMember records
        total = await CommunityMember.prisma().update_many(
            data={
                'joinedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityMemberWhereInput] = None,
        cursor: Optional[types.CommunityMemberWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CommunityMember records present in the database

        Parameters
        ----------
        select
            Select the CommunityMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CommunityMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommunityMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CommunityMember.prisma().count()

        # results: prisma.types.CommunityMemberCountAggregateOutput
        results = await CommunityMember.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CommunityMemberCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityMemberWhereInput] = None,
        cursor: Optional[types.CommunityMemberWhereUniqueInput] = None,
    ) -> types.CommunityMemberCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CommunityMemberCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityMemberWhereInput] = None,
        cursor: Optional[types.CommunityMemberWhereUniqueInput] = None,
    ) -> Union[int, types.CommunityMemberCountAggregateOutput]:
        """Count the number of CommunityMember records present in the database

        Parameters
        ----------
        select
            Select the CommunityMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CommunityMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommunityMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CommunityMember.prisma().count()

        # results: prisma.types.CommunityMemberCountAggregateOutput
        results = await CommunityMember.prisma().count(
            select={
                '_all': True,
                'communityId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CommunityMemberCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CommunityMemberWhereInput] = None
    ) -> int:
        """Delete multiple CommunityMember records.

        Parameters
        ----------
        where
            Optional CommunityMember filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CommunityMember records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CommunityMember records
        total = await CommunityMember.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CommunityMemberScalarFieldKeys'],
        *,
        where: Optional['types.CommunityMemberWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CommunityMemberAvgAggregateInput'] = None,
        sum: Optional['types.CommunityMemberSumAggregateInput'] = None,
        min: Optional['types.CommunityMemberMinAggregateInput'] = None,
        max: Optional['types.CommunityMemberMaxAggregateInput'] = None,
        having: Optional['types.CommunityMemberScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CommunityMemberCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CommunityMemberScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CommunityMemberScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CommunityMemberGroupByOutput']:
        """Group CommunityMember records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CommunityMember fields to group records by
        where
            CommunityMember filter to select records
        take
            Limit the maximum number of CommunityMember records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CommunityMemberGroupByOutput]
            A list of dictionaries representing the CommunityMember record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CommunityMember records by userId values
        # and count how many records are in each group
        results = await CommunityMember.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserStatsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.UserStatsCreateInput,
        include: Optional[types.UserStatsInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserStats record.

        Parameters
        ----------
        data
            UserStats record data
        include
            Specifies which relations should be loaded on the returned UserStats model

        Returns
        -------
        prisma.models.UserStats
            The created UserStats record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserStats record from just the required fields
        userstats = await UserStats.prisma().create(
            data={
                # data to create a UserStats record
                'userId': 'bchhceeeff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserStatsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserStats records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserStats record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserStats.prisma().create_many(
            data=[
                {
                    # data to create a UserStats record
                    'userId': 'bbgaifhdaa',
                },
                {
                    # data to create a UserStats record
                    'userId': 'dgbcdaegb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserStatsWhereUniqueInput,
        include: Optional[types.UserStatsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserStats record.

        Parameters
        ----------
        where
            UserStats filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserStats model

        Returns
        -------
        prisma.models.UserStats
            The deleted UserStats record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userstats = await UserStats.prisma().delete(
            where={
                'id': 'beagfbbjig',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserStatsWhereUniqueInput,
        include: Optional[types.UserStatsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserStats record.

        Parameters
        ----------
        where
            UserStats filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserStats model

        Returns
        -------
        prisma.models.UserStats
            The found UserStats record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userstats = await UserStats.prisma().find_unique(
            where={
                'id': 'beicihhijb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserStatsWhereUniqueInput,
        include: Optional[types.UserStatsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserStats record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserStats filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserStats model

        Returns
        -------
        prisma.models.UserStats
            The found UserStats record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userstats = await UserStats.prisma().find_unique_or_raise(
            where={
                'id': 'fgggcdcjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserStatsWhereInput] = None,
        cursor: Optional[types.UserStatsWhereUniqueInput] = None,
        include: Optional[types.UserStatsInclude] = None,
        order: Optional[Union[types.UserStatsOrderByInput, List[types.UserStatsOrderByInput]]] = None,
        distinct: Optional[List[types.UserStatsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserStats records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserStats records returned
        skip
            Ignore the first N results
        where
            UserStats filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserStats model
        order
            Order the returned UserStats records by any field
        distinct
            Filter UserStats records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserStats]
            The list of all UserStats records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserStats records
        userstats = await UserStats.prisma().find_many(take=10)

        # find the first 5 UserStats records ordered by the id field
        userstats = await UserStats.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserStatsWhereInput] = None,
        cursor: Optional[types.UserStatsWhereUniqueInput] = None,
        include: Optional[types.UserStatsInclude] = None,
        order: Optional[Union[types.UserStatsOrderByInput, List[types.UserStatsOrderByInput]]] = None,
        distinct: Optional[List[types.UserStatsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserStats record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserStats filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserStats model
        order
            Order the returned UserStats records by any field
        distinct
            Filter UserStats records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserStats
            The first UserStats record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserStats record ordered by the userId field
        userstats = await UserStats.prisma().find_first(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserStatsWhereInput] = None,
        cursor: Optional[types.UserStatsWhereUniqueInput] = None,
        include: Optional[types.UserStatsInclude] = None,
        order: Optional[Union[types.UserStatsOrderByInput, List[types.UserStatsOrderByInput]]] = None,
        distinct: Optional[List[types.UserStatsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserStats record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserStats filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserStats model
        order
            Order the returned UserStats records by any field
        distinct
            Filter UserStats records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserStats
            The first UserStats record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserStats record ordered by the messagesSent field
        userstats = await UserStats.prisma().find_first_or_raise(
            skip=1,
            order={
                'messagesSent': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserStatsUpdateInput,
        where: types.UserStatsWhereUniqueInput,
        include: Optional[types.UserStatsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserStats record.

        Parameters
        ----------
        data
            UserStats record data specifying what to update
        where
            UserStats filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserStats model

        Returns
        -------
        prisma.models.UserStats
            The updated UserStats record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userstats = await UserStats.prisma().update(
            where={
                'id': 'ccjbbjigf',
            },
            data={
                # data to update the UserStats record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserStatsWhereUniqueInput,
        data: types.UserStatsUpsertInput,
        include: Optional[types.UserStatsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserStats filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserStats model

        Returns
        -------
        prisma.models.UserStats
            The created or updated UserStats record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userstats = await UserStats.prisma().upsert(
            where={
                'id': 'bhfaabbaha',
            },
            data={
                'create': {
                    'id': 'bhfaabbaha',
                    'userId': 'dgbcdaegb',
                },
                'update': {
                    'userId': 'dgbcdaegb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserStatsUpdateManyMutationInput,
        where: types.UserStatsWhereInput,
    ) -> int:
        """Update multiple UserStats records

        Parameters
        ----------
        data
            UserStats data to update the selected UserStats records to
        where
            Filter to select the UserStats records to update

        Returns
        -------
        int
            The total number of UserStats records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserStats records
        total = await UserStats.prisma().update_many(
            data={
                'messagesReceived': 410943775
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserStatsWhereInput] = None,
        cursor: Optional[types.UserStatsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserStats records present in the database

        Parameters
        ----------
        select
            Select the UserStats fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserStats filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserStatsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserStats.prisma().count()

        # results: prisma.types.UserStatsCountAggregateOutput
        results = await UserStats.prisma().count(
            select={
                '_all': True,
                'charactersTyped': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserStatsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserStatsWhereInput] = None,
        cursor: Optional[types.UserStatsWhereUniqueInput] = None,
    ) -> types.UserStatsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserStatsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserStatsWhereInput] = None,
        cursor: Optional[types.UserStatsWhereUniqueInput] = None,
    ) -> Union[int, types.UserStatsCountAggregateOutput]:
        """Count the number of UserStats records present in the database

        Parameters
        ----------
        select
            Select the UserStats fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserStats filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserStatsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserStats.prisma().count()

        # results: prisma.types.UserStatsCountAggregateOutput
        results = await UserStats.prisma().count(
            select={
                '_all': True,
                'imageMessagesSent': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserStatsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserStatsWhereInput] = None
    ) -> int:
        """Delete multiple UserStats records.

        Parameters
        ----------
        where
            Optional UserStats filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserStats records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserStats records
        total = await UserStats.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserStatsScalarFieldKeys'],
        *,
        where: Optional['types.UserStatsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserStatsAvgAggregateInput'] = None,
        sum: Optional['types.UserStatsSumAggregateInput'] = None,
        min: Optional['types.UserStatsMinAggregateInput'] = None,
        max: Optional['types.UserStatsMaxAggregateInput'] = None,
        having: Optional['types.UserStatsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserStatsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserStatsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserStatsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserStatsGroupByOutput']:
        """Group UserStats records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserStats fields to group records by
        where
            UserStats filter to select records
        take
            Limit the maximum number of UserStats records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserStatsGroupByOutput]
            A list of dictionaries representing the UserStats record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserStats records by filesShared values
        # and count how many records are in each group
        results = await UserStats.prisma().group_by(
            ['filesShared'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserPreferenceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.UserPreferenceCreateInput,
        include: Optional[types.UserPreferenceInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserPreference record.

        Parameters
        ----------
        data
            UserPreference record data
        include
            Specifies which relations should be loaded on the returned UserPreference model

        Returns
        -------
        prisma.models.UserPreference
            The created UserPreference record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserPreference record from just the required fields
        userpreference = await UserPreference.prisma().create(
            data={
                # data to create a UserPreference record
                'userId': 'jajacedge',
                'key': 'hffgbabgf',
                'value': 'biacbiieja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserPreferenceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserPreference records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserPreference record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserPreference.prisma().create_many(
            data=[
                {
                    # data to create a UserPreference record
                    'userId': 'cjejbgbff',
                    'key': 'fgeahddae',
                    'value': 'diageigcf',
                },
                {
                    # data to create a UserPreference record
                    'userId': 'badagbgeha',
                    'key': 'ibgebbjch',
                    'value': 'baieajjiee',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserPreferenceWhereUniqueInput,
        include: Optional[types.UserPreferenceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserPreference record.

        Parameters
        ----------
        where
            UserPreference filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserPreference model

        Returns
        -------
        prisma.models.UserPreference
            The deleted UserPreference record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpreference = await UserPreference.prisma().delete(
            where={
                'id': 'bahjhaccfd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserPreferenceWhereUniqueInput,
        include: Optional[types.UserPreferenceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserPreference record.

        Parameters
        ----------
        where
            UserPreference filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserPreference model

        Returns
        -------
        prisma.models.UserPreference
            The found UserPreference record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpreference = await UserPreference.prisma().find_unique(
            where={
                'id': 'hffhfabhi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserPreferenceWhereUniqueInput,
        include: Optional[types.UserPreferenceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserPreference record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserPreference filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserPreference model

        Returns
        -------
        prisma.models.UserPreference
            The found UserPreference record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpreference = await UserPreference.prisma().find_unique_or_raise(
            where={
                'id': 'bbcigiadhb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPreferenceWhereInput] = None,
        cursor: Optional[types.UserPreferenceWhereUniqueInput] = None,
        include: Optional[types.UserPreferenceInclude] = None,
        order: Optional[Union[types.UserPreferenceOrderByInput, List[types.UserPreferenceOrderByInput]]] = None,
        distinct: Optional[List[types.UserPreferenceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserPreference records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserPreference records returned
        skip
            Ignore the first N results
        where
            UserPreference filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserPreference model
        order
            Order the returned UserPreference records by any field
        distinct
            Filter UserPreference records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserPreference]
            The list of all UserPreference records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserPreference records
        userpreferences = await UserPreference.prisma().find_many(take=10)

        # find the first 5 UserPreference records ordered by the id field
        userpreferences = await UserPreference.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserPreferenceWhereInput] = None,
        cursor: Optional[types.UserPreferenceWhereUniqueInput] = None,
        include: Optional[types.UserPreferenceInclude] = None,
        order: Optional[Union[types.UserPreferenceOrderByInput, List[types.UserPreferenceOrderByInput]]] = None,
        distinct: Optional[List[types.UserPreferenceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserPreference record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserPreference filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserPreference model
        order
            Order the returned UserPreference records by any field
        distinct
            Filter UserPreference records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserPreference
            The first UserPreference record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserPreference record ordered by the userId field
        userpreference = await UserPreference.prisma().find_first(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserPreferenceWhereInput] = None,
        cursor: Optional[types.UserPreferenceWhereUniqueInput] = None,
        include: Optional[types.UserPreferenceInclude] = None,
        order: Optional[Union[types.UserPreferenceOrderByInput, List[types.UserPreferenceOrderByInput]]] = None,
        distinct: Optional[List[types.UserPreferenceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserPreference record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserPreference filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserPreference model
        order
            Order the returned UserPreference records by any field
        distinct
            Filter UserPreference records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserPreference
            The first UserPreference record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserPreference record ordered by the key field
        userpreference = await UserPreference.prisma().find_first_or_raise(
            skip=1,
            order={
                'key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserPreferenceUpdateInput,
        where: types.UserPreferenceWhereUniqueInput,
        include: Optional[types.UserPreferenceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserPreference record.

        Parameters
        ----------
        data
            UserPreference record data specifying what to update
        where
            UserPreference filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserPreference model

        Returns
        -------
        prisma.models.UserPreference
            The updated UserPreference record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userpreference = await UserPreference.prisma().update(
            where={
                'id': 'cfjagbbae',
            },
            data={
                # data to update the UserPreference record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserPreferenceWhereUniqueInput,
        data: types.UserPreferenceUpsertInput,
        include: Optional[types.UserPreferenceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserPreference filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserPreference model

        Returns
        -------
        prisma.models.UserPreference
            The created or updated UserPreference record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpreference = await UserPreference.prisma().upsert(
            where={
                'id': 'bbbfhdidef',
            },
            data={
                'create': {
                    'id': 'bbbfhdidef',
                    'userId': 'badagbgeha',
                    'key': 'ibgebbjch',
                    'value': 'baieajjiee',
                },
                'update': {
                    'userId': 'badagbgeha',
                    'key': 'ibgebbjch',
                    'value': 'baieajjiee',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserPreferenceUpdateManyMutationInput,
        where: types.UserPreferenceWhereInput,
    ) -> int:
        """Update multiple UserPreference records

        Parameters
        ----------
        data
            UserPreference data to update the selected UserPreference records to
        where
            Filter to select the UserPreference records to update

        Returns
        -------
        int
            The total number of UserPreference records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserPreference records
        total = await UserPreference.prisma().update_many(
            data={
                'value': 'bdadhibhec'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPreferenceWhereInput] = None,
        cursor: Optional[types.UserPreferenceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserPreference records present in the database

        Parameters
        ----------
        select
            Select the UserPreference fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserPreference filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserPreferenceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserPreference.prisma().count()

        # results: prisma.types.UserPreferenceCountAggregateOutput
        results = await UserPreference.prisma().count(
            select={
                '_all': True,
                'valueType': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserPreferenceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPreferenceWhereInput] = None,
        cursor: Optional[types.UserPreferenceWhereUniqueInput] = None,
    ) -> types.UserPreferenceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserPreferenceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPreferenceWhereInput] = None,
        cursor: Optional[types.UserPreferenceWhereUniqueInput] = None,
    ) -> Union[int, types.UserPreferenceCountAggregateOutput]:
        """Count the number of UserPreference records present in the database

        Parameters
        ----------
        select
            Select the UserPreference fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserPreference filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserPreferenceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserPreference.prisma().count()

        # results: prisma.types.UserPreferenceCountAggregateOutput
        results = await UserPreference.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserPreferenceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserPreferenceWhereInput] = None
    ) -> int:
        """Delete multiple UserPreference records.

        Parameters
        ----------
        where
            Optional UserPreference filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserPreference records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserPreference records
        total = await UserPreference.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserPreferenceScalarFieldKeys'],
        *,
        where: Optional['types.UserPreferenceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserPreferenceAvgAggregateInput'] = None,
        sum: Optional['types.UserPreferenceSumAggregateInput'] = None,
        min: Optional['types.UserPreferenceMinAggregateInput'] = None,
        max: Optional['types.UserPreferenceMaxAggregateInput'] = None,
        having: Optional['types.UserPreferenceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserPreferenceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserPreferenceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserPreferenceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserPreferenceGroupByOutput']:
        """Group UserPreference records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserPreference fields to group records by
        where
            UserPreference filter to select records
        take
            Limit the maximum number of UserPreference records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserPreferenceGroupByOutput]
            A list of dictionaries representing the UserPreference record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserPreference records by createdAt values
        # and count how many records are in each group
        results = await UserPreference.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ConversationPreferenceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.ConversationPreferenceCreateInput,
        include: Optional[types.ConversationPreferenceInclude] = None
    ) -> _PrismaModelT:
        """Create a new ConversationPreference record.

        Parameters
        ----------
        data
            ConversationPreference record data
        include
            Specifies which relations should be loaded on the returned ConversationPreference model

        Returns
        -------
        prisma.models.ConversationPreference
            The created ConversationPreference record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ConversationPreference record from just the required fields
        conversationpreference = await ConversationPreference.prisma().create(
            data={
                # data to create a ConversationPreference record
                'conversationId': 'bfhdjaiejf',
                'userId': 'bbjfijjadg',
                'key': 'hdjacbehh',
                'value': 'bhcccbeaba',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ConversationPreferenceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ConversationPreference records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ConversationPreference record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ConversationPreference.prisma().create_many(
            data=[
                {
                    # data to create a ConversationPreference record
                    'conversationId': 'bcgjbdgjdj',
                    'userId': 'fhdbhifae',
                    'key': 'beeacgfcej',
                    'value': 'bbifhdiicc',
                },
                {
                    # data to create a ConversationPreference record
                    'conversationId': 'bgjeccejad',
                    'userId': 'bjagdgabbg',
                    'key': 'bjbbcffdij',
                    'value': 'begcgchdi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ConversationPreferenceWhereUniqueInput,
        include: Optional[types.ConversationPreferenceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ConversationPreference record.

        Parameters
        ----------
        where
            ConversationPreference filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationPreference model

        Returns
        -------
        prisma.models.ConversationPreference
            The deleted ConversationPreference record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationpreference = await ConversationPreference.prisma().delete(
            where={
                'id': 'bhbjceagbb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ConversationPreferenceWhereUniqueInput,
        include: Optional[types.ConversationPreferenceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ConversationPreference record.

        Parameters
        ----------
        where
            ConversationPreference filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationPreference model

        Returns
        -------
        prisma.models.ConversationPreference
            The found ConversationPreference record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationpreference = await ConversationPreference.prisma().find_unique(
            where={
                'id': 'bjeifffjdg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ConversationPreferenceWhereUniqueInput,
        include: Optional[types.ConversationPreferenceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ConversationPreference record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ConversationPreference filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationPreference model

        Returns
        -------
        prisma.models.ConversationPreference
            The found ConversationPreference record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationpreference = await ConversationPreference.prisma().find_unique_or_raise(
            where={
                'id': 'bdidcfdfjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationPreferenceWhereInput] = None,
        cursor: Optional[types.ConversationPreferenceWhereUniqueInput] = None,
        include: Optional[types.ConversationPreferenceInclude] = None,
        order: Optional[Union[types.ConversationPreferenceOrderByInput, List[types.ConversationPreferenceOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationPreferenceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ConversationPreference records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ConversationPreference records returned
        skip
            Ignore the first N results
        where
            ConversationPreference filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationPreference model
        order
            Order the returned ConversationPreference records by any field
        distinct
            Filter ConversationPreference records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ConversationPreference]
            The list of all ConversationPreference records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ConversationPreference records
        conversationpreferences = await ConversationPreference.prisma().find_many(take=10)

        # find the first 5 ConversationPreference records ordered by the id field
        conversationpreferences = await ConversationPreference.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationPreferenceWhereInput] = None,
        cursor: Optional[types.ConversationPreferenceWhereUniqueInput] = None,
        include: Optional[types.ConversationPreferenceInclude] = None,
        order: Optional[Union[types.ConversationPreferenceOrderByInput, List[types.ConversationPreferenceOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationPreferenceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ConversationPreference record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ConversationPreference filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationPreference model
        order
            Order the returned ConversationPreference records by any field
        distinct
            Filter ConversationPreference records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ConversationPreference
            The first ConversationPreference record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ConversationPreference record ordered by the conversationId field
        conversationpreference = await ConversationPreference.prisma().find_first(
            skip=1,
            order={
                'conversationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationPreferenceWhereInput] = None,
        cursor: Optional[types.ConversationPreferenceWhereUniqueInput] = None,
        include: Optional[types.ConversationPreferenceInclude] = None,
        order: Optional[Union[types.ConversationPreferenceOrderByInput, List[types.ConversationPreferenceOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationPreferenceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ConversationPreference record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ConversationPreference filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationPreference model
        order
            Order the returned ConversationPreference records by any field
        distinct
            Filter ConversationPreference records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ConversationPreference
            The first ConversationPreference record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ConversationPreference record ordered by the userId field
        conversationpreference = await ConversationPreference.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ConversationPreferenceUpdateInput,
        where: types.ConversationPreferenceWhereUniqueInput,
        include: Optional[types.ConversationPreferenceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ConversationPreference record.

        Parameters
        ----------
        data
            ConversationPreference record data specifying what to update
        where
            ConversationPreference filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ConversationPreference model

        Returns
        -------
        prisma.models.ConversationPreference
            The updated ConversationPreference record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        conversationpreference = await ConversationPreference.prisma().update(
            where={
                'id': 'dfeggejja',
            },
            data={
                # data to update the ConversationPreference record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ConversationPreferenceWhereUniqueInput,
        data: types.ConversationPreferenceUpsertInput,
        include: Optional[types.ConversationPreferenceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ConversationPreference filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ConversationPreference model

        Returns
        -------
        prisma.models.ConversationPreference
            The created or updated ConversationPreference record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationpreference = await ConversationPreference.prisma().upsert(
            where={
                'id': 'gehbgghbj',
            },
            data={
                'create': {
                    'id': 'gehbgghbj',
                    'conversationId': 'bgjeccejad',
                    'userId': 'bjagdgabbg',
                    'key': 'bjbbcffdij',
                    'value': 'begcgchdi',
                },
                'update': {
                    'conversationId': 'bgjeccejad',
                    'userId': 'bjagdgabbg',
                    'key': 'bjbbcffdij',
                    'value': 'begcgchdi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ConversationPreferenceUpdateManyMutationInput,
        where: types.ConversationPreferenceWhereInput,
    ) -> int:
        """Update multiple ConversationPreference records

        Parameters
        ----------
        data
            ConversationPreference data to update the selected ConversationPreference records to
        where
            Filter to select the ConversationPreference records to update

        Returns
        -------
        int
            The total number of ConversationPreference records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ConversationPreference records
        total = await ConversationPreference.prisma().update_many(
            data={
                'key': 'dfhaijeie'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationPreferenceWhereInput] = None,
        cursor: Optional[types.ConversationPreferenceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ConversationPreference records present in the database

        Parameters
        ----------
        select
            Select the ConversationPreference fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ConversationPreference filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationPreferenceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ConversationPreference.prisma().count()

        # results: prisma.types.ConversationPreferenceCountAggregateOutput
        results = await ConversationPreference.prisma().count(
            select={
                '_all': True,
                'value': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ConversationPreferenceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationPreferenceWhereInput] = None,
        cursor: Optional[types.ConversationPreferenceWhereUniqueInput] = None,
    ) -> types.ConversationPreferenceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ConversationPreferenceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationPreferenceWhereInput] = None,
        cursor: Optional[types.ConversationPreferenceWhereUniqueInput] = None,
    ) -> Union[int, types.ConversationPreferenceCountAggregateOutput]:
        """Count the number of ConversationPreference records present in the database

        Parameters
        ----------
        select
            Select the ConversationPreference fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ConversationPreference filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationPreferenceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ConversationPreference.prisma().count()

        # results: prisma.types.ConversationPreferenceCountAggregateOutput
        results = await ConversationPreference.prisma().count(
            select={
                '_all': True,
                'valueType': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ConversationPreferenceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ConversationPreferenceWhereInput] = None
    ) -> int:
        """Delete multiple ConversationPreference records.

        Parameters
        ----------
        where
            Optional ConversationPreference filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ConversationPreference records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ConversationPreference records
        total = await ConversationPreference.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ConversationPreferenceScalarFieldKeys'],
        *,
        where: Optional['types.ConversationPreferenceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ConversationPreferenceAvgAggregateInput'] = None,
        sum: Optional['types.ConversationPreferenceSumAggregateInput'] = None,
        min: Optional['types.ConversationPreferenceMinAggregateInput'] = None,
        max: Optional['types.ConversationPreferenceMaxAggregateInput'] = None,
        having: Optional['types.ConversationPreferenceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ConversationPreferenceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ConversationPreferenceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ConversationPreferenceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ConversationPreferenceGroupByOutput']:
        """Group ConversationPreference records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ConversationPreference fields to group records by
        where
            ConversationPreference filter to select records
        take
            Limit the maximum number of ConversationPreference records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ConversationPreferenceGroupByOutput]
            A list of dictionaries representing the ConversationPreference record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ConversationPreference records by description values
        # and count how many records are in each group
        results = await ConversationPreference.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CommunityAdminActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.CommunityAdminCreateInput,
        include: Optional[types.CommunityAdminInclude] = None
    ) -> _PrismaModelT:
        """Create a new CommunityAdmin record.

        Parameters
        ----------
        data
            CommunityAdmin record data
        include
            Specifies which relations should be loaded on the returned CommunityAdmin model

        Returns
        -------
        prisma.models.CommunityAdmin
            The created CommunityAdmin record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CommunityAdmin record from just the required fields
        communityadmin = await CommunityAdmin.prisma().create(
            data={
                # data to create a CommunityAdmin record
                'communityId': 'gbcdjgicb',
                'userId': 'biaibdagac',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CommunityAdminCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CommunityAdmin records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CommunityAdmin record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CommunityAdmin.prisma().create_many(
            data=[
                {
                    # data to create a CommunityAdmin record
                    'communityId': 'bbfbheibcd',
                    'userId': 'hiagajie',
                },
                {
                    # data to create a CommunityAdmin record
                    'communityId': 'eeejidbif',
                    'userId': 'efgbahec',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CommunityAdminWhereUniqueInput,
        include: Optional[types.CommunityAdminInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CommunityAdmin record.

        Parameters
        ----------
        where
            CommunityAdmin filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CommunityAdmin model

        Returns
        -------
        prisma.models.CommunityAdmin
            The deleted CommunityAdmin record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        communityadmin = await CommunityAdmin.prisma().delete(
            where={
                'id': 'hgjaiebfb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CommunityAdminWhereUniqueInput,
        include: Optional[types.CommunityAdminInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CommunityAdmin record.

        Parameters
        ----------
        where
            CommunityAdmin filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CommunityAdmin model

        Returns
        -------
        prisma.models.CommunityAdmin
            The found CommunityAdmin record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        communityadmin = await CommunityAdmin.prisma().find_unique(
            where={
                'id': 'bddefjjabc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CommunityAdminWhereUniqueInput,
        include: Optional[types.CommunityAdminInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CommunityAdmin record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CommunityAdmin filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CommunityAdmin model

        Returns
        -------
        prisma.models.CommunityAdmin
            The found CommunityAdmin record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        communityadmin = await CommunityAdmin.prisma().find_unique_or_raise(
            where={
                'id': 'bbbghgbadh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityAdminWhereInput] = None,
        cursor: Optional[types.CommunityAdminWhereUniqueInput] = None,
        include: Optional[types.CommunityAdminInclude] = None,
        order: Optional[Union[types.CommunityAdminOrderByInput, List[types.CommunityAdminOrderByInput]]] = None,
        distinct: Optional[List[types.CommunityAdminScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CommunityAdmin records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CommunityAdmin records returned
        skip
            Ignore the first N results
        where
            CommunityAdmin filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommunityAdmin model
        order
            Order the returned CommunityAdmin records by any field
        distinct
            Filter CommunityAdmin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CommunityAdmin]
            The list of all CommunityAdmin records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CommunityAdmin records
        communityadmins = await CommunityAdmin.prisma().find_many(take=10)

        # find the first 5 CommunityAdmin records ordered by the id field
        communityadmins = await CommunityAdmin.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommunityAdminWhereInput] = None,
        cursor: Optional[types.CommunityAdminWhereUniqueInput] = None,
        include: Optional[types.CommunityAdminInclude] = None,
        order: Optional[Union[types.CommunityAdminOrderByInput, List[types.CommunityAdminOrderByInput]]] = None,
        distinct: Optional[List[types.CommunityAdminScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CommunityAdmin record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CommunityAdmin filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommunityAdmin model
        order
            Order the returned CommunityAdmin records by any field
        distinct
            Filter CommunityAdmin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CommunityAdmin
            The first CommunityAdmin record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CommunityAdmin record ordered by the communityId field
        communityadmin = await CommunityAdmin.prisma().find_first(
            skip=1,
            order={
                'communityId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommunityAdminWhereInput] = None,
        cursor: Optional[types.CommunityAdminWhereUniqueInput] = None,
        include: Optional[types.CommunityAdminInclude] = None,
        order: Optional[Union[types.CommunityAdminOrderByInput, List[types.CommunityAdminOrderByInput]]] = None,
        distinct: Optional[List[types.CommunityAdminScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CommunityAdmin record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CommunityAdmin filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommunityAdmin model
        order
            Order the returned CommunityAdmin records by any field
        distinct
            Filter CommunityAdmin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CommunityAdmin
            The first CommunityAdmin record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CommunityAdmin record ordered by the userId field
        communityadmin = await CommunityAdmin.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CommunityAdminUpdateInput,
        where: types.CommunityAdminWhereUniqueInput,
        include: Optional[types.CommunityAdminInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CommunityAdmin record.

        Parameters
        ----------
        data
            CommunityAdmin record data specifying what to update
        where
            CommunityAdmin filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CommunityAdmin model

        Returns
        -------
        prisma.models.CommunityAdmin
            The updated CommunityAdmin record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        communityadmin = await CommunityAdmin.prisma().update(
            where={
                'id': 'bbhcgagaic',
            },
            data={
                # data to update the CommunityAdmin record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CommunityAdminWhereUniqueInput,
        data: types.CommunityAdminUpsertInput,
        include: Optional[types.CommunityAdminInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CommunityAdmin filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CommunityAdmin model

        Returns
        -------
        prisma.models.CommunityAdmin
            The created or updated CommunityAdmin record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        communityadmin = await CommunityAdmin.prisma().upsert(
            where={
                'id': 'ddaabegbb',
            },
            data={
                'create': {
                    'id': 'ddaabegbb',
                    'communityId': 'eeejidbif',
                    'userId': 'efgbahec',
                },
                'update': {
                    'communityId': 'eeejidbif',
                    'userId': 'efgbahec',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CommunityAdminUpdateManyMutationInput,
        where: types.CommunityAdminWhereInput,
    ) -> int:
        """Update multiple CommunityAdmin records

        Parameters
        ----------
        data
            CommunityAdmin data to update the selected CommunityAdmin records to
        where
            Filter to select the CommunityAdmin records to update

        Returns
        -------
        int
            The total number of CommunityAdmin records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CommunityAdmin records
        total = await CommunityAdmin.prisma().update_many(
            data={
                'assignedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityAdminWhereInput] = None,
        cursor: Optional[types.CommunityAdminWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CommunityAdmin records present in the database

        Parameters
        ----------
        select
            Select the CommunityAdmin fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CommunityAdmin filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommunityAdminCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CommunityAdmin.prisma().count()

        # results: prisma.types.CommunityAdminCountAggregateOutput
        results = await CommunityAdmin.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CommunityAdminCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityAdminWhereInput] = None,
        cursor: Optional[types.CommunityAdminWhereUniqueInput] = None,
    ) -> types.CommunityAdminCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CommunityAdminCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityAdminWhereInput] = None,
        cursor: Optional[types.CommunityAdminWhereUniqueInput] = None,
    ) -> Union[int, types.CommunityAdminCountAggregateOutput]:
        """Count the number of CommunityAdmin records present in the database

        Parameters
        ----------
        select
            Select the CommunityAdmin fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CommunityAdmin filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommunityAdminCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CommunityAdmin.prisma().count()

        # results: prisma.types.CommunityAdminCountAggregateOutput
        results = await CommunityAdmin.prisma().count(
            select={
                '_all': True,
                'communityId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CommunityAdminCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CommunityAdminWhereInput] = None
    ) -> int:
        """Delete multiple CommunityAdmin records.

        Parameters
        ----------
        where
            Optional CommunityAdmin filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CommunityAdmin records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CommunityAdmin records
        total = await CommunityAdmin.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CommunityAdminScalarFieldKeys'],
        *,
        where: Optional['types.CommunityAdminWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CommunityAdminAvgAggregateInput'] = None,
        sum: Optional['types.CommunityAdminSumAggregateInput'] = None,
        min: Optional['types.CommunityAdminMinAggregateInput'] = None,
        max: Optional['types.CommunityAdminMaxAggregateInput'] = None,
        having: Optional['types.CommunityAdminScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CommunityAdminCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CommunityAdminScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CommunityAdminScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CommunityAdminGroupByOutput']:
        """Group CommunityAdmin records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CommunityAdmin fields to group records by
        where
            CommunityAdmin filter to select records
        take
            Limit the maximum number of CommunityAdmin records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CommunityAdminGroupByOutput]
            A list of dictionaries representing the CommunityAdmin record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CommunityAdmin records by userId values
        # and count how many records are in each group
        results = await CommunityAdmin.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CommunityModeratorActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.CommunityModeratorCreateInput,
        include: Optional[types.CommunityModeratorInclude] = None
    ) -> _PrismaModelT:
        """Create a new CommunityModerator record.

        Parameters
        ----------
        data
            CommunityModerator record data
        include
            Specifies which relations should be loaded on the returned CommunityModerator model

        Returns
        -------
        prisma.models.CommunityModerator
            The created CommunityModerator record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CommunityModerator record from just the required fields
        communitymoderator = await CommunityModerator.prisma().create(
            data={
                # data to create a CommunityModerator record
                'communityId': 'bhgibfgbbc',
                'userId': 'hbgcihef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CommunityModeratorCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CommunityModerator records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CommunityModerator record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CommunityModerator.prisma().create_many(
            data=[
                {
                    # data to create a CommunityModerator record
                    'communityId': 'ffhgghde',
                    'userId': 'ibcadcejf',
                },
                {
                    # data to create a CommunityModerator record
                    'communityId': 'bdcdfgccdg',
                    'userId': 'edhjgdfh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CommunityModeratorWhereUniqueInput,
        include: Optional[types.CommunityModeratorInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CommunityModerator record.

        Parameters
        ----------
        where
            CommunityModerator filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CommunityModerator model

        Returns
        -------
        prisma.models.CommunityModerator
            The deleted CommunityModerator record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        communitymoderator = await CommunityModerator.prisma().delete(
            where={
                'id': 'bdeffdadda',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CommunityModeratorWhereUniqueInput,
        include: Optional[types.CommunityModeratorInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CommunityModerator record.

        Parameters
        ----------
        where
            CommunityModerator filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CommunityModerator model

        Returns
        -------
        prisma.models.CommunityModerator
            The found CommunityModerator record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        communitymoderator = await CommunityModerator.prisma().find_unique(
            where={
                'id': 'bjgfdihchf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CommunityModeratorWhereUniqueInput,
        include: Optional[types.CommunityModeratorInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CommunityModerator record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CommunityModerator filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CommunityModerator model

        Returns
        -------
        prisma.models.CommunityModerator
            The found CommunityModerator record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        communitymoderator = await CommunityModerator.prisma().find_unique_or_raise(
            where={
                'id': 'iaeihdeei',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityModeratorWhereInput] = None,
        cursor: Optional[types.CommunityModeratorWhereUniqueInput] = None,
        include: Optional[types.CommunityModeratorInclude] = None,
        order: Optional[Union[types.CommunityModeratorOrderByInput, List[types.CommunityModeratorOrderByInput]]] = None,
        distinct: Optional[List[types.CommunityModeratorScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CommunityModerator records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CommunityModerator records returned
        skip
            Ignore the first N results
        where
            CommunityModerator filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommunityModerator model
        order
            Order the returned CommunityModerator records by any field
        distinct
            Filter CommunityModerator records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CommunityModerator]
            The list of all CommunityModerator records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CommunityModerator records
        communitymoderators = await CommunityModerator.prisma().find_many(take=10)

        # find the first 5 CommunityModerator records ordered by the id field
        communitymoderators = await CommunityModerator.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommunityModeratorWhereInput] = None,
        cursor: Optional[types.CommunityModeratorWhereUniqueInput] = None,
        include: Optional[types.CommunityModeratorInclude] = None,
        order: Optional[Union[types.CommunityModeratorOrderByInput, List[types.CommunityModeratorOrderByInput]]] = None,
        distinct: Optional[List[types.CommunityModeratorScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CommunityModerator record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CommunityModerator filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommunityModerator model
        order
            Order the returned CommunityModerator records by any field
        distinct
            Filter CommunityModerator records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CommunityModerator
            The first CommunityModerator record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CommunityModerator record ordered by the communityId field
        communitymoderator = await CommunityModerator.prisma().find_first(
            skip=1,
            order={
                'communityId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommunityModeratorWhereInput] = None,
        cursor: Optional[types.CommunityModeratorWhereUniqueInput] = None,
        include: Optional[types.CommunityModeratorInclude] = None,
        order: Optional[Union[types.CommunityModeratorOrderByInput, List[types.CommunityModeratorOrderByInput]]] = None,
        distinct: Optional[List[types.CommunityModeratorScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CommunityModerator record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CommunityModerator filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommunityModerator model
        order
            Order the returned CommunityModerator records by any field
        distinct
            Filter CommunityModerator records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CommunityModerator
            The first CommunityModerator record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CommunityModerator record ordered by the userId field
        communitymoderator = await CommunityModerator.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CommunityModeratorUpdateInput,
        where: types.CommunityModeratorWhereUniqueInput,
        include: Optional[types.CommunityModeratorInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CommunityModerator record.

        Parameters
        ----------
        data
            CommunityModerator record data specifying what to update
        where
            CommunityModerator filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CommunityModerator model

        Returns
        -------
        prisma.models.CommunityModerator
            The updated CommunityModerator record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        communitymoderator = await CommunityModerator.prisma().update(
            where={
                'id': 'bfggejgfbd',
            },
            data={
                # data to update the CommunityModerator record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CommunityModeratorWhereUniqueInput,
        data: types.CommunityModeratorUpsertInput,
        include: Optional[types.CommunityModeratorInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CommunityModerator filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CommunityModerator model

        Returns
        -------
        prisma.models.CommunityModerator
            The created or updated CommunityModerator record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        communitymoderator = await CommunityModerator.prisma().upsert(
            where={
                'id': 'ifaaaedja',
            },
            data={
                'create': {
                    'id': 'ifaaaedja',
                    'communityId': 'bdcdfgccdg',
                    'userId': 'edhjgdfh',
                },
                'update': {
                    'communityId': 'bdcdfgccdg',
                    'userId': 'edhjgdfh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CommunityModeratorUpdateManyMutationInput,
        where: types.CommunityModeratorWhereInput,
    ) -> int:
        """Update multiple CommunityModerator records

        Parameters
        ----------
        data
            CommunityModerator data to update the selected CommunityModerator records to
        where
            Filter to select the CommunityModerator records to update

        Returns
        -------
        int
            The total number of CommunityModerator records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CommunityModerator records
        total = await CommunityModerator.prisma().update_many(
            data={
                'assignedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityModeratorWhereInput] = None,
        cursor: Optional[types.CommunityModeratorWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CommunityModerator records present in the database

        Parameters
        ----------
        select
            Select the CommunityModerator fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CommunityModerator filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommunityModeratorCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CommunityModerator.prisma().count()

        # results: prisma.types.CommunityModeratorCountAggregateOutput
        results = await CommunityModerator.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CommunityModeratorCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityModeratorWhereInput] = None,
        cursor: Optional[types.CommunityModeratorWhereUniqueInput] = None,
    ) -> types.CommunityModeratorCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CommunityModeratorCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommunityModeratorWhereInput] = None,
        cursor: Optional[types.CommunityModeratorWhereUniqueInput] = None,
    ) -> Union[int, types.CommunityModeratorCountAggregateOutput]:
        """Count the number of CommunityModerator records present in the database

        Parameters
        ----------
        select
            Select the CommunityModerator fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CommunityModerator filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommunityModeratorCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CommunityModerator.prisma().count()

        # results: prisma.types.CommunityModeratorCountAggregateOutput
        results = await CommunityModerator.prisma().count(
            select={
                '_all': True,
                'communityId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CommunityModeratorCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CommunityModeratorWhereInput] = None
    ) -> int:
        """Delete multiple CommunityModerator records.

        Parameters
        ----------
        where
            Optional CommunityModerator filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CommunityModerator records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CommunityModerator records
        total = await CommunityModerator.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CommunityModeratorScalarFieldKeys'],
        *,
        where: Optional['types.CommunityModeratorWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CommunityModeratorAvgAggregateInput'] = None,
        sum: Optional['types.CommunityModeratorSumAggregateInput'] = None,
        min: Optional['types.CommunityModeratorMinAggregateInput'] = None,
        max: Optional['types.CommunityModeratorMaxAggregateInput'] = None,
        having: Optional['types.CommunityModeratorScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CommunityModeratorCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CommunityModeratorScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CommunityModeratorScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CommunityModeratorGroupByOutput']:
        """Group CommunityModerator records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CommunityModerator fields to group records by
        where
            CommunityModerator filter to select records
        take
            Limit the maximum number of CommunityModerator records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CommunityModeratorGroupByOutput]
            A list of dictionaries representing the CommunityModerator record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CommunityModerator records by userId values
        # and count how many records are in each group
        results = await CommunityModerator.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models