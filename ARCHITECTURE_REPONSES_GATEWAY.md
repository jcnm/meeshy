# üîÑ Architecture des R√©ponses vers la Gateway

## üìä Vue d'ensemble

Le syst√®me de traduction utilise une architecture **PUB/SUB + PUSH/PULL** pour la communication entre le Translator et la Gateway. Voici comment les r√©ponses sont renvoy√©es :

## üèóÔ∏è Architecture ZMQ

### üîÑ Flux de Communication

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    PUSH     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    PUB      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Gateway     ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ    Translator   ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ     Gateway     ‚îÇ
‚îÇ                 ‚îÇ (Commandes) ‚îÇ                 ‚îÇ (R√©ponses)  ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                                ‚îÇ                                ‚îÇ
        ‚îÇ                                ‚îÇ                                ‚îÇ
        ‚îÇ                                ‚îÇ                                ‚îÇ
        ‚ñº                                ‚ñº                                ‚ñº
   PUSH Socket                      PULL Socket                    SUB Socket
   (Port 5555)                      (Port 5555)                    (Port 5558)
```

### üì° Ports de Communication

| Composant | Socket | Port | Direction | Usage |
|-----------|--------|------|-----------|-------|
| **Gateway** | PUSH | 5555 | Gateway ‚Üí Translator | Envoi des commandes de traduction |
| **Translator** | PULL | 5555 | Gateway ‚Üí Translator | R√©ception des commandes |
| **Translator** | PUB | 5558 | Translator ‚Üí Gateway | Envoi des r√©sultats |
| **Gateway** | SUB | 5558 | Translator ‚Üí Gateway | R√©ception des r√©sultats |

## üîÑ Processus de R√©ponse

### 1Ô∏è‚É£ R√©ception de la Commande (Translator)

```python
# Dans le Translator (zmq_server.py)
async def _handle_translation_request(self, message: bytes):
    """Traite une requ√™te de traduction re√ßue via PULL"""
    try:
        request_data = json.loads(message.decode('utf-8'))
        
        # Cr√©er la t√¢che de traduction
        task = TranslationTask(
            task_id=str(uuid.uuid4()),
            message_id=request_data.get('messageId'),
            text=request_data.get('text'),
            source_language=request_data.get('sourceLanguage', 'fr'),
            target_languages=request_data.get('targetLanguages', []),
            conversation_id=request_data.get('conversationId', 'unknown'),
            model_type=request_data.get('modelType', 'basic')
        )
        
        # Enfiler la t√¢che dans la pool appropri√©e
        success = await self.pool_manager.enqueue_task(task)
        
    except Exception as e:
        logger.error(f"Erreur lors du traitement de la requ√™te: {e}")
```

### 2Ô∏è‚É£ Traitement de la Traduction

```python
# Dans le Translator (zmq_server.py)
async def _process_translation_task(self, task: TranslationTask, worker_name: str):
    """Traite une t√¢che de traduction avec traduction parall√®le"""
    try:
        # Lancer les traductions en parall√®le
        translation_tasks = []
        
        for target_language in task.target_languages:
            translation_task = asyncio.create_task(
                self._translate_single_language(task, target_language, worker_name)
            )
            translation_tasks.append((target_language, translation_task))
        
        # Attendre toutes les traductions
        for target_language, translation_task in translation_tasks:
            try:
                result = await translation_task
                # Publier le r√©sultat via PUB
                await self._publish_translation_result(task.task_id, result, target_language)
                
            except Exception as e:
                logger.error(f"Erreur de traduction pour {target_language}: {e}")
                # Publier un r√©sultat d'erreur
                error_result = self._create_error_result(task, target_language, str(e))
                await self._publish_translation_result(task.task_id, error_result, target_language)
                
    except Exception as e:
        logger.error(f"Erreur lors du traitement de la t√¢che {task.task_id}: {e}")
```

### 3Ô∏è‚É£ Envoi de la R√©ponse (Translator)

```python
# Dans le Translator (zmq_server.py)
async def _publish_translation_result(self, task_id: str, result: dict, target_language: str):
    """Publie un r√©sultat de traduction via PUB vers la gateway"""
    try:
        message = {
            'type': 'translation_completed',
            'taskId': task_id,
            'result': result,
            'targetLanguage': target_language,
            'timestamp': time.time()
        }
        
        # Utiliser le socket PUB configur√© pour envoyer √† la gateway
        if self.pub_socket:
            await self.pub_socket.send(json.dumps(message).encode('utf-8'))
            logger.info(f"üì§ [TRANSLATOR] R√©sultat envoy√© vers gateway: {task_id} -> {target_language}")
        else:
            logger.error("‚ùå Socket PUB non initialis√©")
            
    except Exception as e:
        logger.error(f"Erreur lors de la publication du r√©sultat: {e}")
```

### 4Ô∏è‚É£ R√©ception de la R√©ponse (Gateway)

```typescript
// Dans la Gateway (zmq-translation-client.ts)
private async _startResultListener(): Promise<void> {
    logger.info('üéß [ZMQ-Client] D√©marrage √©coute des r√©sultats de traduction...');

    (async () => {
        try {
            while (this.running) {
                try {
                    // Recevoir un message avec timeout
                    const [message] = await this.subSocket.receive();
                    
                    logger.info(`üì® [ZMQ-Client] Message re√ßu (taille: ${message.length} bytes)`);
                    
                    await this._handleTranslationResult(message);
                    
                } catch (error) {
                    if (this.running) {
                        logger.error(`‚ùå Erreur r√©ception r√©sultat: ${error}`);
                    }
                    break;
                }
            }
        } catch (error) {
            logger.error(`‚ùå Erreur boucle √©coute r√©sultats: ${error}`);
        }
    })();
}

private async _handleTranslationResult(message: Buffer): Promise<void> {
    try {
        const messageStr = message.toString('utf-8');
        const event: TranslationEvent = JSON.parse(messageStr);
        
        this.stats.results_received++;
        
        if (event.type === 'translation_completed') {
            logger.info(`‚úÖ [ZMQ-Client] Traduction termin√©e: ${event.taskId} -> ${event.targetLanguage}`);
            
            // √âmettre l'√©v√©nement de traduction termin√©e
            this.emit('translationCompleted', {
                taskId: event.taskId,
                result: event.result,
                targetLanguage: event.targetLanguage
            });
            
            // Nettoyer la requ√™te en cours
            this.pendingRequests.delete(event.taskId);
            
        } else if (event.type === 'translation_error') {
            this.stats.errors_received++;
            
            logger.error(`‚ùå [ZMQ-Client] Erreur de traduction: ${event.error} pour ${event.messageId}`);
            
            // √âmettre l'√©v√©nement d'erreur
            this.emit('translationError', {
                taskId: event.taskId,
                messageId: event.messageId,
                error: event.error,
                conversationId: event.conversationId
            });
            
            // Nettoyer la requ√™te en cours
            this.pendingRequests.delete(event.taskId);
        }
        
    } catch (error) {
        logger.error(`‚ùå [ZMQ-Client] Erreur traitement r√©sultat: ${error}`);
    }
}
```

## üìã Format des Messages

### üì§ Commande envoy√©e par la Gateway

```json
{
  "taskId": "uuid-1234-5678-9abc",
  "messageId": "msg-456",
  "text": "Bonjour tout le monde",
  "sourceLanguage": "fr",
  "targetLanguages": ["en", "es", "de"],
  "conversationId": "conv-789",
  "modelType": "basic",
  "timestamp": 1640995200000
}
```

### üì• R√©ponse envoy√©e par le Translator

```json
{
  "type": "translation_completed",
  "taskId": "uuid-1234-5678-9abc",
  "result": {
    "messageId": "msg-456",
    "translatedText": "Hello everyone",
    "sourceLanguage": "fr",
    "targetLanguage": "en",
    "confidenceScore": 0.95,
    "processingTime": 0.123,
    "modelType": "basic",
    "workerName": "normal_worker_0"
  },
  "targetLanguage": "en",
  "timestamp": 1640995200123
}
```

### ‚ùå Message d'erreur

```json
{
  "type": "translation_error",
  "taskId": "uuid-1234-5678-9abc",
  "messageId": "msg-456",
  "error": "translation pool full",
  "conversationId": "conv-789"
}
```

## üîß Configuration des Sockets

### Translator (C√¥t√© Serveur)

```python
# Initialisation des sockets
async def initialize(self):
    """Initialise les sockets ZMQ avec architecture PUSH/PULL + PUB/SUB"""
    try:
        # Socket PULL pour recevoir les commandes du Gateway
        self.pull_socket = self.context.socket(zmq.PULL)
        self.pull_socket.bind(f"tcp://{self.host}:{self.gateway_push_port}")
        
        # Socket PUB pour publier les r√©sultats vers le Gateway
        self.pub_socket = self.context.socket(zmq.PUB)
        self.pub_socket.bind(f"tcp://{self.host}:{self.gateway_sub_port}")
        
        logger.info(f"üîå Socket PULL li√© au port: {self.host}:{self.gateway_push_port}")
        logger.info(f"üîå Socket PUB li√© au port: {self.host}:{self.gateway_sub_port}")
        
    except Exception as e:
        logger.error(f"Erreur lors de l'initialisation: {e}")
        raise
```

### Gateway (C√¥t√© Client)

```typescript
async initialize(): Promise<void> {
    try {
        // Cr√©er le contexte ZMQ
        this.context = new zmq.Context();
        
        // Socket PUSH pour envoyer les commandes de traduction
        this.pushSocket = new zmq.Push();
        await this.pushSocket.connect(`tcp://${this.host}:${this.pushPort}`);
        
        // Socket SUB pour recevoir les r√©sultats
        this.subSocket = new zmq.Subscriber();
        await this.subSocket.connect(`tcp://${this.host}:${this.subPort}`);
        await this.subSocket.subscribe(''); // S'abonner √† tous les messages
        
        // D√©marrer l'√©coute des r√©sultats
        this._startResultListener();
        
        this.running = true;
        logger.info(`üîå [ZMQ-Client] Socket PUSH connect√©: ${this.host}:${this.pushPort}`);
        logger.info(`üîå [ZMQ-Client] Socket SUB connect√©: ${this.host}:${this.subPort}`);
        
    } catch (error) {
        logger.error(`‚ùå Erreur initialisation ZMQTranslationClient: ${error}`);
        throw error;
    }
}
```

## üéØ Avantages de cette Architecture

### ‚úÖ Performance
- **Asynchrone** : Les r√©ponses sont envoy√©es d√®s qu'elles sont pr√™tes
- **Parall√®le** : Plusieurs traductions peuvent √™tre trait√©es simultan√©ment
- **Non-bloquant** : La Gateway n'attend pas les r√©ponses

### ‚úÖ Fiabilit√©
- **PUB/SUB** : Les messages sont distribu√©s √† tous les abonn√©s
- **PUSH/PULL** : Distribution √©quitable des t√¢ches entre les workers
- **Gestion d'erreurs** : Messages d'erreur d√©di√©s

### ‚úÖ Scalabilit√©
- **Multi-workers** : Plusieurs workers peuvent traiter les traductions
- **Pool de connexions** : Gestion efficace des ressources
- **Cache** : R√©duction de la charge de traduction

## üîç Monitoring et Debugging

### üìä Statistiques Collect√©es

```typescript
interface ZMQClientStats {
  requests_sent: number;        // Nombre de requ√™tes envoy√©es
  results_received: number;     // Nombre de r√©sultats re√ßus
  errors_received: number;      // Nombre d'erreurs re√ßues
  pool_full_rejections: number; // Nombre de rejets (pool pleine)
  avg_response_time: number;    // Temps de r√©ponse moyen
  uptime_seconds: number;       // Temps de fonctionnement
  memory_usage_mb: number;      // Utilisation m√©moire
}
```

### üìù Logs D√©taill√©s

```typescript
// Logs d'envoi
logger.info(`üì§ [ZMQ-Client] Commande PUSH envoy√©e: taskId=${taskId}`);

// Logs de r√©ception
logger.info(`üì• [ZMQ-Client] R√©sultat ZMQ re√ßu: type=${event.type}`);

// Logs d'erreur
logger.error(`‚ùå [ZMQ-Client] Erreur de traduction: ${event.error}`);
```

## üéâ Conclusion

L'architecture de communication entre le Translator et la Gateway est **robuste, performante et scalable** :

1. **üì§ Envoi** : Gateway ‚Üí Translator via PUSH/PULL (port 5555)
2. **üîÑ Traitement** : Translator traite les traductions en parall√®le
3. **üì• R√©ponse** : Translator ‚Üí Gateway via PUB/SUB (port 5558)
4. **üì° Distribution** : Gateway distribue les r√©sultats aux clients

Cette architecture garantit une **communication fiable et efficace** entre les composants du syst√®me de traduction.
